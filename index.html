<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lysterfield Sailing Club Results</title>
    <style>
        /* CSS Styles (Existing styles merged with additions for boat list) */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f8ff;
        }
        h1, h2, h3 {
            color: #003366;
        }
        h4 { /* Style for Race N headers */
             color: #003366;
             margin-top: 15px;
             margin-bottom: 5px;
             border-bottom: 1px solid #ccc;
             padding-bottom: 3px;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box; /* Important for width: 100% */
        }
        /* Allow inputs/selects in specific containers to be auto width */
        .filter-group select, .filter-group input,
        .series-select select, .series-select input,
        .short-course-race-entry select, .short-course-race-entry input,
        #entries-table .table-entry-select, #entries-table .table-entry-input /* Added for standard entries table */
         {
            width: auto;
            padding: 4px 6px; /* Smaller padding for table inputs */
            font-size: 13px; /* Slightly smaller font */
        }
         /* Make time inputs wider in short course table and standard entries table */
        .short-course-race-entry input[type="text"],
        #entries-table .table-entry-input[type="text"] /* Added for standard entries table */
         {
             min-width: 80px;
         }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] { /* Target only checkboxes */
            width: auto;
            margin-right: 8px;
        }
        .checkbox-group label {
            display: inline;
            margin-bottom: 0;
            font-weight: normal; /* Normal weight for checkbox labels */
        }
        button {
            background-color: #003366;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px; /* Add bottom margin for wrapping */
        }
        button:hover {
            background-color: #004080;
        }
        .btn-secondary { background-color: #4682B4; }
        .btn-secondary:hover { background-color: #5891c4; }
        .btn-warning { background-color: #ff9800; }
        .btn-warning:hover { background-color: #e68a00; }
        .btn-danger { background-color: #dc3545; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-edit { background-color: #28a745; }
        .btn-edit:hover { background-color: #218838; }
        .btn-save { background-color: #17a2b8; }
        .btn-save:hover { background-color: #138496; }
        .btn-create-race { background-color: #ff9800; } /* Orange for Create Race */
        .btn-create-race:hover { background-color: #e68a00; }

        /* Results Styling */
        .results-table, #boat-list-table, #entries-table, .short-course-race-table { /* Apply common table styles */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        .results-table th, #boat-list-table th, #entries-table th, .short-course-race-table th {
            background-color: #003366;
            color: white;
            text-align: left;
            padding: 6px 8px;
            font-weight: bold;
        }
        .results-table td, #boat-list-table td, #entries-table td, .short-course-race-table td {
            padding: 4px 8px;
            border: 1px solid #ddd; /* Add border to all table cells */
            text-align: left;
            vertical-align: middle; /* Align content vertically */
        }
        .results-table tr:nth-child(even), #boat-list-table tr:nth-child(even),
        #entries-table tr:nth-child(even), .short-course-race-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .results-table tr:hover, #boat-list-table tr:hover,
        #entries-table tr:hover, .short-course-race-table tr:hover {
            background-color: #e8f4ff;
        }

        .race-info-panel {
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .race-info-panel h3 { margin-top: 0; margin-bottom: 5px; }
        .race-info-panel p { margin: 5px 0; }

        /* Removed colour rules */

        .discarded { text-decoration: line-through; color: #888; font-style: italic; }
        .legend { font-size: 12px; margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; }
        .legend span { margin-right: 5px; display: inline-block; }
        .legend strong { margin-right: 10px; }
        .legend .discarded-example { text-decoration: line-through; font-style: italic; color: #888; }

        .actions { display: flex; gap: 5px; flex-wrap: wrap; align-items: center; } /* Added align-items */
        .actions button { margin-right: 0; margin-bottom: 0; padding: 3px 6px; font-size: 10px; } /* Removed bottom margin */

        .entry-form, #boat-list-form /* Apply style to both forms */ {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .status-option { display: flex; align-items: center; margin: 10px 0; }
        /* Make radio buttons smaller and aligned */
        .status-option input[type="radio"] {
             width: auto;
             margin-right: 8px;
             padding: 0; /* Remove default padding */
             vertical-align: middle; /* Align with label text */
        }
        .status-option label {
            display: inline; /* Allow label next to radio */
            margin-bottom: 0; /* Remove block spacing */
            font-weight: normal; /* Normal weight */
             vertical-align: middle; /* Align with radio button */
        }
        .entry-buttons { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .result-highlight { background-color: #fffce8 !important; }
        .tab-buttons { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 5px; }
        .tab-buttons button { margin-right: 0; }
        .tab-content { display: none; }
        .active-tab { display: block; }
        .active-button { background-color: #0056b3; }

        /* Race Card general styling */
        .race-card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px; /* Default padding */
            margin-bottom: 15px; /* Default margin */
            background-color: #f9f9f9;
        }
        .race-card h3 {
            margin-top: 0;
            margin-bottom: 10px; /* Default for h3 in card */
        }
        .race-info { display: flex; justify-content: space-between; margin-bottom: 10px; flex-wrap: wrap; }
        .race-actions { margin-top: 10px; }

        /* More compact styling for series cards in #series-list */
        #series-list .race-card {
            padding: 10px;
            margin-bottom: 10px;
        }
        #series-list .race-card .race-info h3 { /* Target h3 inside .race-info specific to series list cards */
            margin-bottom: 5px;
        }
        #series-list .race-card .series-card-details {
            font-size: 13px;
            color: #333;
            margin-top: 0;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        #series-list .race-card .race-actions button { /* Smaller buttons for series cards */
            padding: 4px 8px;
            font-size: 12px;
        }


        .series-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .series-select { margin-bottom: 20px; }
        .series-date { margin-top: 10px; }
        .edit-mode-warning { background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-bottom: 15px; border: 1px solid #ffeeba; color: #856404; }
        .race-view-container { margin-top: 15px; }
        .race-selector { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .race-selector button { padding: 5px 10px; font-size: 12px; }
        .race-button { background-color: #f2f2f2; color: #333; border: 1px solid #ddd; }
        .race-button.active { background-color: #003366; color: white; }
        .race-button.has-results { border: 2px solid #28a745; }
        #boat-list-table th:last-child, #boat-list-table td:last-child { width: auto; min-width: 100px; text-align: center; } /* Actions col for boat list */
        #entries-table th:nth-child(5), #entries-table td:nth-child(5) { width: 120px; } /* Status Col Width for standard entries */
        #entries-table th:nth-child(6), #entries-table td:nth-child(6) { width: 100px; } /* Time Col Width for standard entries */
        #entries-table th:last-child, #entries-table td:last-child { width: auto; min-width: 60px; text-align: center; } /* Actions col for entries */
        .short-course-race-table th:nth-child(5), .short-course-race-table td:nth-child(5) { width: 120px; } /* Status Col Width */
        .short-course-race-table th:nth-child(6), .short-course-race-table td:nth-child(6) { width: 100px; } /* Time Col Width */
        .short-course-race-table th:last-child, .short-course-race-table td:last-child { width: auto; min-width: 60px; text-align: center; } /* Actions Col Width */

        .series-results-table td, .series-results-table th { white-space: nowrap; }
        .series-results-table .nr-cell { color: #999; font-style: italic; text-align: center; }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; }
        .action-buttons button { margin-right: 0; }
        #saved-boat-selector { margin-bottom: 20px; }
        #saved-boat-selector label { margin-bottom: 8px; }
        .hidden { display: none !important; }

        #short-course-races-container {
            margin-top: 25px;
            border-top: 2px solid #003366;
            padding-top: 15px;
        }
        .short-course-race-section {
             border: 1px solid #ccc;
             border-radius: 5px;
             padding: 10px 15px;
             margin-bottom: 15px;
             background-color: #f9f9f9;
        }
        .short-course-race-section h4 { margin-top: 0; }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="hidden">Saving to Cloud...</div> <!-- Loading Indicator -->
    <div class="container">
        <h1>Lysterfield Results App</h1>

        <div class="tab-buttons">
            <button id="btn-series" class="active-button">Series Management</button>
            <button id="btn-boat-list">Boat List</button>
            <button id="btn-race">Race Entry</button>
            <button id="btn-results">Race Results</button>
            <button id="btn-series-results">Series Viewer</button>
            <button id="btn-race-view">Race Viewer</button>
        </div>

        <!-- Series Management Tab -->
        <div id="series-tab" class="tab-content active-tab">
            <div class="series-header"><h2>Series Management</h2><button id="create-series-btn">Create New Series</button></div>
            <!-- Series Create/Edit Form -->
            <div id="create-series-form" class="entry-form hidden"> <!-- Start hidden -->
                <h3>Create/Edit Series</h3>
                <div class="form-group">
                    <label for="series-name">Series Name:</label>
                    <input type="text" id="series-name" placeholder="e.g., Summer Series 2024">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="series-short-course">
                    <label for="series-short-course">Tick this box if Short Courses</label>
                </div>
                <div id="short-course-discard-options" class="hidden"> <!-- Hidden by default -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="series-short-course-discard-5">
                        <label for="series-short-course-discard-5">Apply 1 discard if 5 or more races are completed</label>
                    </div>
                </div>
                <div id="standard-series-options"> <!-- Wrapper for options hidden in short course -->
                    <div class="form-group">
                        <label for="number-of-races">Number of Races Planned:</label>
                        <input type="number" id="number-of-races" min="1" max="50" value="8">
                    </div>
                    <div class="form-group">
                        <label for="races-per-discard">Discard 1 race after how many completed races? (Enter 0 for no discards)</label>
                        <input type="number" id="races-per-discard" min="0" max="20" value="4">
                        <small>Example: If set to 4, 1 discard applies after race 4, 2 discards after race 8, etc.</small>
                    </div>
                </div>
                <div id="dnc-scoring-options-group"> <!-- Wrapper for DNC options -->
                    <div class="form-group">
                        <label>DNC Points Calculation:</label>
                        <div class="status-option">
                            <input type="radio" id="dnc-rule-race" name="dnc-scoring-rule" value="raceEntries" checked>
                            <label for="dnc-rule-race">Entries in specific Race + 1</label>
                        </div>
                        <div class="status-option">
                            <input type="radio" id="dnc-rule-series" name="dnc-scoring-rule" value="seriesCompetitors">
                            <label for="dnc-rule-series">Total unique competitors in Series + 1</label>
                        </div>
                    </div>
                </div>

                <input type="hidden" id="edit-series-id">
                <div class="entry-buttons">
                    <button id="save-series-btn">Save Series</button>
                    <button id="cancel-series-btn" class="btn-secondary">Cancel</button>
                </div>
            </div>
            <!-- Series List Display -->
            <div id="series-list">
                <!-- Series cards will be generated here -->
            </div>

            <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                <h3>Data Management (Local JSON Files)</h3>
                <button id="export-all-data-btn" class="btn-secondary">Export All Data (JSON)</button>
                <button id="import-data-btn" class="btn-warning">Import Data (JSON - Replaces Current)</button>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    These buttons manage local JSON file backups. Data is primarily saved to Google Sheets.
                    Import will <strong>replace</strong> all current data (in app & then saved to Sheets) with the data from the selected file.
                </p>
            </div>

        </div> <!-- End of series-tab -->


        <!-- Boat List Tab -->
        <div id="boat-list-tab" class="tab-content">
             <div class="series-header">
                <h2>Manage Boat List</h2>
                <button id="show-add-boat-form-btn">Add New Boat</button>
            </div>
             <div id="boat-list-form" class="entry-form hidden"> <!-- Start hidden -->
                 <h3 id="boat-form-title">Add New Boat</h3>
                 <div class="form-group">
                     <label for="boat-sail-number">Sail Number: If a club boat, replace sail number with boat class - Example: Club Pacer or Club Sabre</label>
                     <input type="text" id="boat-sail-number" placeholder="e.g., AUS123">
                 </div>
                  <div class="form-group">
                     <label for="boat-class-list">Boat Class:</label>
                     <select id="boat-class-list">
                         <option value="">Select boat class</option>
                         <!-- Populated from yardstick data -->
                     </select>
                 </div>
                 <div class="checkbox-group">
                     <input type="checkbox" id="boat-manual-class-check">
                     <label for="boat-manual-class-check">Enter boat class manually</label>
                 </div>
                 <div id="boat-manual-class-input" class="form-group hidden"> <!-- Use class -->
                     <label for="boat-manual-boat-class">Custom Boat Class:</label>
                     <input type="text" id="boat-manual-boat-class" placeholder="Enter custom boat class">
                 </div>
                  <div class="form-group">
                     <label for="boat-skipper">Skipper Name:</label>
                     <input type="text" id="boat-skipper" placeholder="Full name">
                 </div>
                  <div class="form-group">
                     <label for="boat-yardstick">Yardstick:</label>
                     <input type="number" id="boat-yardstick" step="0.1" placeholder="Auto-filled or enter manually">
                 </div>
                 <input type="hidden" id="editing-boat-id" value="">
                 <div class="entry-buttons">
                     <button id="save-boat-list-btn">Save Boat</button>
                     <button id="cancel-boat-list-btn" class="btn-secondary">Cancel</button>
                 </div>
             </div>
             <h3>Saved Boats</h3>
              <div style="overflow-x: auto;">
                 <table id="boat-list-table">
                     <thead>
                         <tr>
                             <th>Sail #</th>
                             <th>Boat Class</th>
                             <th>Skipper</th>
                             <th>Yardstick</th>
                             <th>Actions</th>
                         </tr>
                     </thead>
                     <tbody id="boat-list-body"></tbody>
                 </table>
             </div>

              <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                 <h3>Boat List Data Management (Local JSON Files)</h3>
                 <button id="export-boat-list-btn" class="btn-secondary">Export Boat List Only (JSON)</button>
                 <button id="import-boat-list-btn" class="btn-warning">Import Boat List (JSON - Replaces Current)</button>
                 <input type="file" id="import-boat-list-file-input" accept=".json" style="display: none;">
                 <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    Export creates a JSON backup of the current saved boat list.
                    Import will <strong>replace</strong> the current boat list (in app & then saved to Sheets).
                 </p>
             </div>
        </div> <!-- End of boat-list-tab -->

        <!-- Race Entry Tab -->
        <div id="race-tab" class="tab-content">
            <h2>Race Entry</h2>

           <div class="series-select">
                <label for="select-series">Select Series:</label>
                <select id="select-series"></select>
                <span id="race-selector-wrapper">
                    <label for="select-race" style="margin-left: 0px;">Select Race Number:</label>
                    <select id="select-race"></select>
                </span>
            </div>

            <div id="edit-mode-warning" class="edit-mode-warning hidden"></div>

            <!-- Entry Form -->
            <div class="entry-form">
                <h3 id="entry-form-title">Add/Edit Boat Entry</h3>

                <div id="saved-boat-selector" class="form-group">
                    <label for="select-saved-boat">Select Saved Boat:</label>
                    <select id="select-saved-boat">
                        <option value="">-- Select Saved Boat --</option>
                    </select>
                    <small>Select a boat to add to the race.</small>
                </div>

                <div class="form-group">
                    <label for="yardstick">Yardstick:</label>
                    <input type="number" id="yardstick" step="0.1" placeholder="Enter yardstick">
                    <small>Manually change yardstick if needed.</small>
                </div>

                <div id="standard-entry-fields">
                    <!-- Race Status and Elapsed Time inputs were here, now removed for standard series main form -->
                    <!-- These inputs are still needed for the 'editShortCourseEntry' path, so they are kept in HTML and JS manipulates visibility if needed -->
                    <div id="main-form-status-group" class="form-group hidden"> <!-- Hidden by default, shown by editShortCourseEntry if needed -->
                        <label>Race Status:</label>
                        <div class="status-option"><input type="radio" id="status-finished" name="race-status" value="finished" checked><label for="status-finished">Finished</label></div>
                        <div class="status-option"><input type="radio" id="status-dnf" name="race-status" value="DNF"><label for="status-dnf">DNF</label></div>
                        <div class="status-option"><input type="radio" id="status-dns" name="race-status" value="DNS"><label for="status-dns">DNS</label></div>
                        <div class="status-option"><input type="radio" id="status-ocs" name="race-status" value="OCS"><label for="status-ocs">OCS</label></div>
                        <div class="status-option"><input type="radio" id="status-dsq" name="race-status" value="DSQ"><label for="status-dsq">DSQ</label></div>
                        <div class="status-option"><input type="radio" id="status-ood" name="race-status" value="OOD"><label for="status-ood">OOD</label></div>
                    </div>
                    <div id="time-inputs" class="form-group hidden"> <!-- Hidden by default, shown by editShortCourseEntry if status is 'finished' -->
                        <label for="elapsed-time">Elapsed Time (h:m:s / h m s / m:s / m s):</label>
                        <input type="text" id="elapsed-time" placeholder="e.g. 1:30:45 / 1 30 45 / 30:45 / 30 45">
                    </div>
                </div>


                <div class="entry-buttons">
                    <button id="add-boat">Add Boat</button>
                    <button id="update-boat" class="btn-edit hidden">Update Boat</button>
                    <button id="cancel-update" class="btn-secondary hidden">Cancel Update</button>
                    <button id="clear-form" class="btn-secondary">Clear Form</button>
                </div>
                <input type="hidden" id="editing-entry-index" value="-1">
                <input type="hidden" id="editing-short-course-race-index" value="-1">
            </div>

            <div id="standard-entries-display">
                <h3 id="current-entries-heading">Entries</h3>
                <div style="overflow-x: auto;">
                    <table id="entries-table">
                        <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr></thead>
                        <tbody id="entries-body"></tbody>
                    </table>
                </div>
            </div>

            <div id="short-course-staging-display" class="hidden">
                <h3 id="short-course-pool-heading">Race Entries (Add/Remove Boats Here)</h3>
                 <div style="overflow-x: auto;">
                     <table id="short-course-pool-table" class="results-table">
                         <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Actions</th></tr></thead>
                         <tbody id="short-course-pool-body"></tbody>
                     </table>
                 </div>
                 <div class="action-buttons">
                     <button id="create-short-course-race-btn" class="btn-create-race">Create Race 1</button>
                     <button id="remove-last-short-course-race-btn" class="btn-warning hidden">Remove Last Created Race</button>
                 </div>
            </div>

             <div id="short-course-races-container" class="hidden">
                 <h3>Created Races (This Session)</h3>
             </div>


            <div style="margin-top: 20px;" class="action-buttons">
                <button id="calculate-results">Calculate Results and Save</button>
                <button id="clear-all" class="btn-warning">Clear Current List/Pool</button>
                <button id="clear-short-course-session-btn" class="btn-danger hidden">Clear Created Races</button>
            </div>
        </div>


        <!-- Race Results Tab -->
        <div id="results-tab" class="tab-content">
             <h2>Race Results</h2>
             <div id="result-race-info"></div>
             <!-- Save button removed from here -->
             <div style="overflow-x: auto;">
                 <table id="results-table" class="results-table">
                     <thead>
                         <tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th></tr>
                     </thead>
                     <tbody id="results-body"></tbody>
                 </table>
             </div>
        </div>

        <!-- Series Results Tab -->
        <div id="series-results-tab" class="tab-content">
             <h2>Series Results</h2>
             <div class="series-select"><label for="view-series-select">Select Series:</label><select id="view-series-select"></select></div>
             <div id="series-summary"></div>
             <div style="overflow-x: auto;"><table id="series-results-table" class="results-table series-results-table"><thead id="series-results-header"></thead><tbody id="series-results-body"></tbody></table></div>
             <div class="legend"><strong>Legend:</strong></div>
        </div>

        <!-- Race Viewer Tab -->
        <div id="race-view-tab" class="tab-content">
             <h2>Race Viewer</h2>
             <div class="series-select"><label for="view-all-series-select">Select Series:</label><select id="view-all-series-select"></select></div>
             <div id="race-summary-view"></div>
             <div class="race-selector"></div>
             <div class="race-view-container"><div id="individual-race-info"></div><div style="overflow-x: auto;"><table id="individual-race-results" class="results-table"><thead></thead><tbody id="individual-race-body"></tbody></table></div></div>
        </div>

    </div>

    <script>
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyTHgUnij7DiwsbKiA7jjNHjNohNfxXW9mtJpkt4XlDrlAXpGoaT4JLeEfSkwcosJHXcw/exec';

        // Yardstick data (still needed for dropdowns)
        const yardstickData = [
            { boatClass: "125", yardstick: 123 }, { boatClass: "145", yardstick: 113 }, { boatClass: "29er", yardstick: 95 }, { boatClass: "420", yardstick: 112 }, { boatClass: "470", yardstick: 101 },
            { boatClass: "505", yardstick: 93 }, { boatClass: "B14", yardstick: 94 }, { boatClass: "Byte", yardstick: 125.4 }, { boatClass: "Byte CII", yardstick: 120.4 }, { boatClass: "Cherub", yardstick: 100 },
            { boatClass: "Contender", yardstick: 106.5 }, { boatClass: "Corsair", yardstick: 119.5 }, { boatClass: "E Class (Lazy E)", yardstick: 113 }, { boatClass: "Europe Dinghy", yardstick: 120 },
            { boatClass: "Fireball", yardstick: 101 }, { boatClass: "Finn", yardstick: 110 }, { boatClass: "Flying Ant", yardstick: 136 }, { boatClass: "Flying 11", yardstick: 117 }, { boatClass: "Heron", yardstick: 134 },
            { boatClass: "Impulse", yardstick: 118.5 }, { boatClass: "Impulse 6.6", yardstick: 124.5 }, { boatClass: "Javelin", yardstick: 97.5 }, { boatClass: "Jubilee", yardstick: 130 }, { boatClass: "Laser", yardstick: 114 },
            { boatClass: "Laser Radial", yardstick: 118.5 }, { boatClass: "Laser 4.7", yardstick: 127 }, { boatClass: "Mirror", yardstick: 143 }, { boatClass: "Moth Skiff", yardstick: 110 }, { boatClass: "Moth Scow", yardstick: 115 },
            { boatClass: "NS14", yardstick: 108 }, { boatClass: "OK Dinghy", yardstick: 115.5 }, { boatClass: "Open Bic", yardstick: 153.3 }, { boatClass: "Optimist", yardstick: 170 }, { boatClass: "Pacer", yardstick: 127.5 },
            { boatClass: "Pacer Non Spinnaker", yardstick: 130.4}, { boatClass: "RS 100 8.4", yardstick: 106 }, { boatClass: "RS 100 10.2", yardstick: 103 }, { boatClass: "RS 200", yardstick: 108.5 }, { boatClass: "RS 300", yardstick: 103.4 },
            { boatClass: "RS 400", yardstick: 96.6 }, { boatClass: "RS 500", yardstick: 102.7 }, { boatClass: "RS 600", yardstick: 87.2 }, { boatClass: "RS 700", yardstick: 83.8 }, { boatClass: "RS 800", yardstick: 86.3 },
            { boatClass: "RS Aero 5", yardstick: 116.8 }, { boatClass: "RS Aero 6", yardstick: 114.6 }, { boatClass: "RS Aero 7", yardstick: 112.5 }, { boatClass: "RS Aero 9", yardstick: 108 }, { boatClass: "RS Feva XL", yardstick: 130 },
            { boatClass: "RS Tera Pro", yardstick: 143.2 }, { boatClass: "RS Tera Sport", yardstick: 153.9 }, { boatClass: "RS Vareo", yardstick: 113.1 }, { boatClass: "RS Vision", yardstick: 123.7 }, { boatClass: "Sabre", yardstick: 127 },
            { boatClass: "Sailfish", yardstick: 132 }, { boatClass: "Sparrow", yardstick: 145 }, { boatClass: "Solo", yardstick: 123.5 }, { boatClass: "Sabot", yardstick: 160.5 }, { boatClass: "Sharpie", yardstick: 95 },
            { boatClass: "Spiral", yardstick: 124 }, { boatClass: "Tasar", yardstick: 108 },
        ];

        // --- App State ---
        let entries = [];
        let results = [];
        let series = [];
        let boatList = [];
        let shortCourseSessionRaces = [];
        let currentSeries = null;
        let currentRace = null; // This will store the race number (integer)
        let editMode = false;

        // --- DOM Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const seriesTab = document.getElementById('series-tab');
        const raceTab = document.getElementById('race-tab');
        const resultsTab = document.getElementById('results-tab');
        const seriesResultsTab = document.getElementById('series-results-tab');
        const raceViewTab = document.getElementById('race-view-tab');
        const boatListTab = document.getElementById('boat-list-tab');
        const btnSeries = document.getElementById('btn-series');
        const btnRace = document.getElementById('btn-race');
        const btnResults = document.getElementById('btn-results');
        const btnSeriesResults = document.getElementById('btn-series-results');
        const btnRaceView = document.getElementById('btn-race-view');
        const btnBoatList = document.getElementById('btn-boat-list');

        const entryFormTitle = document.getElementById('entry-form-title');
        const yardstickValue = document.getElementById('yardstick');
        const elapsedTime = document.getElementById('elapsed-time'); 
        const timeInputs = document.getElementById('time-inputs'); 
        const mainFormStatusGroup = document.getElementById('main-form-status-group'); 
        const statusRadios = document.querySelectorAll('input[name="race-status"]'); 
        const addBoatBtn = document.getElementById('add-boat');
        const updateBoatBtn = document.getElementById('update-boat');
        const cancelUpdateBtn = document.getElementById('cancel-update');
        const clearFormBtn = document.getElementById('clear-form');
        const editingEntryIndexInput = document.getElementById('editing-entry-index');
        const editingShortCourseRaceIndexInput = document.getElementById('editing-short-course-race-index');
        const entriesBody = document.getElementById('entries-body');
        const calculateResultsBtn = document.getElementById('calculate-results');
        const clearAllBtn = document.getElementById('clear-all');
        const editModeWarning = document.getElementById('edit-mode-warning');
        const selectSavedBoat = document.getElementById('select-saved-boat');
        const standardEntryFields = document.getElementById('standard-entry-fields'); 
        const raceSelectorWrapper = document.getElementById('race-selector-wrapper');

        const standardEntriesDisplay = document.getElementById('standard-entries-display');
        const currentEntriesHeading = document.getElementById('current-entries-heading');

        const shortCourseStagingDisplay = document.getElementById('short-course-staging-display');
        const shortCoursePoolHeading = document.getElementById('short-course-pool-heading');
        const shortCoursePoolBody = document.getElementById('short-course-pool-body');
        const createShortCourseRaceBtn = document.getElementById('create-short-course-race-btn');
        const removeLastShortCourseRaceBtn = document.getElementById('remove-last-short-course-race-btn');
        const shortCourseRacesContainer = document.getElementById('short-course-races-container');
        const clearShortCourseSessionBtn = document.getElementById('clear-short-course-session-btn');

        const selectSeries = document.getElementById('select-series');
        const selectRace = document.getElementById('select-race');
        const viewSeries = document.getElementById('view-series-select');
        const viewAllSeries = document.getElementById('view-all-series-select');

        const resultsBody = document.getElementById('results-body');
        const resultRaceInfo = document.getElementById('result-race-info');
        // const saveResultsTabBtn = document.getElementById('save-results-tab-btn'); // Button is removed from HTML

        const seriesResultsBody = document.getElementById('series-results-body');
        const seriesResultsHeader = document.getElementById('series-results-header');
        const seriesSummary = document.getElementById('series-summary');
        const legendDiv = document.querySelector('.legend');

        const raceSummaryView = document.getElementById('race-summary-view');
        const raceSelector = document.querySelector('.race-selector');
        const individualRaceInfo = document.getElementById('individual-race-info');
        const individualRaceBody = document.getElementById('individual-race-body');
        const individualRaceHeader = document.querySelector('#individual-race-results thead');
        if (individualRaceHeader) {
            individualRaceHeader.innerHTML = '<tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th></tr>';
        }

        const createSeriesBtn = document.getElementById('create-series-btn');
        const saveSeriesBtn = document.getElementById('save-series-btn');
        const cancelSeriesBtn = document.getElementById('cancel-series-btn');
        const seriesName = document.getElementById('series-name');
        const seriesShortCourseCheck = document.getElementById('series-short-course');
        const shortCourseDiscardOptionsDiv = document.getElementById('short-course-discard-options');
        const seriesShortCourseDiscard5Check = document.getElementById('series-short-course-discard-5');
        const standardSeriesOptions = document.getElementById('standard-series-options');
        const dncScoringOptionsGroup = document.getElementById('dnc-scoring-options-group');
        const numberOfRaces = document.getElementById('number-of-races');
        const racesPerDiscardInput = document.getElementById('races-per-discard');
        const editSeriesId = document.getElementById('edit-series-id');
        const createSeriesForm = document.getElementById('create-series-form');
        const seriesList = document.getElementById('series-list');

        const showAddBoatFormBtn = document.getElementById('show-add-boat-form-btn');
        const boatListForm = document.getElementById('boat-list-form');
        const boatFormTitle = document.getElementById('boat-form-title');
        const boatSailNumber = document.getElementById('boat-sail-number');
        const boatClassList = document.getElementById('boat-class-list');
        const boatManualClassCheck = document.getElementById('boat-manual-class-check');
        const boatManualClassInput = document.getElementById('boat-manual-class-input');
        const boatManualBoatClass = document.getElementById('boat-manual-boat-class');
        const boatSkipper = document.getElementById('boat-skipper');
        const boatYardstick = document.getElementById('boat-yardstick');
        const editingBoatId = document.getElementById('editing-boat-id');
        const saveBoatListBtn = document.getElementById('save-boat-list-btn');
        const cancelBoatListBtn = document.getElementById('cancel-boat-list-btn');
        const boatListTable = document.getElementById('boat-list-table');
        const boatListBody = document.getElementById('boat-list-body');

        const exportAllDataBtn = document.getElementById('export-all-data-btn');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        const exportBoatListBtn = document.getElementById('export-boat-list-btn');
        const importBoatListBtn = document.getElementById('import-boat-list-btn');
        const importBoatListFileInput = document.getElementById('import-boat-list-file-input');


        // --- Utility Functions ---
        function timeToSeconds(timeStr) {
            if (!timeStr) return -1; // Use -1 to indicate "not parsed" or "invalid"
            timeStr = String(timeStr).trim();

            // Order matters: check for more specific (3-part) before less specific (2-part)
            const hmsColonRegex = /^([0-9]{1,2}):([0-5]?[0-9]):([0-5]?[0-9])$/;
            const hmsSpaceRegex = /^([0-9]{1,2})\s+([0-5]?[0-9])\s+([0-5]?[0-9])$/;
            const msColonRegex = /^([0-5]?[0-9]):([0-5]?[0-9])$/;
            const msSpaceRegex = /^([0-5]?[0-9])\s+([0-5]?[0-9])$/;

            let match;
            let hours = 0, minutes = 0, seconds = 0;

            if ((match = timeStr.match(hmsColonRegex)) || (match = timeStr.match(hmsSpaceRegex))) {
                hours = parseInt(match[1], 10);
                minutes = parseInt(match[2], 10);
                seconds = parseInt(match[3], 10);
            } else if ((match = timeStr.match(msColonRegex)) || (match = timeStr.match(msSpaceRegex))) {
                hours = 0; // No hours in this format
                minutes = parseInt(match[1], 10);
                seconds = parseInt(match[2], 10);
            } else {
                return -1; // Not a recognized format
            }

            // Validate component ranges
            if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) ||
                hours < 0 || hours > 99 ||
                minutes < 0 || minutes > 59 ||
                seconds < 0 || seconds > 59) {
                return -1; // Invalid range or NaN from parsing
            }
            return hours * 3600 + minutes * 60 + seconds;
        }

        function isValidTimeFormat(timeStr) {
            if (!timeStr) return false;
            // A time string is valid if timeToSeconds parses it successfully (returns >= 0)
            return timeToSeconds(String(timeStr).trim()) >= 0;
        }
        
        function secondsToTime(seconds) { if (isNaN(seconds) || seconds === null || seconds < 0) return ''; seconds = Math.round(seconds); const hours = Math.floor(seconds / 3600); let minutes = Math.floor((seconds % 3600) / 60); let secs = seconds % 60; if (secs === 60) { minutes += 1; secs = 0; } if (minutes === 60) { /* hours += 1; */ minutes = 0; } return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
        function pluralize(count, singular, plural = null) { return count === 1 ? singular : (plural || singular + 's'); }


        // --- Tab Navigation ---
        function setActiveTab(tabElement) {
             document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active-tab'));
             document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active-button'));

             if (tabElement) {
                 tabElement.classList.add('active-tab');
                 const buttonId = 'btn-' + tabElement.id.replace('-tab', '');
                 const correspondingButton = document.getElementById(buttonId);
                 if(correspondingButton) { correspondingButton.classList.add('active-button'); }
                 else { console.warn("Could not find button for tab:", buttonId); }
             } else { console.error("setActiveTab called with null element"); }

             if (tabElement?.id !== 'race-tab') {
                editMode = false;
                editModeWarning?.classList.add('hidden');
                if (shortCourseSessionRaces.length > 0) {
                    console.log("Navigating away from Race Entry tab, clearing short course session.");
                    clearShortCourseSessionData();
                }
             }
             if (tabElement?.id !== 'boat-list-tab') { boatListForm?.classList.add('hidden'); }
             if (tabElement?.id !== 'series-tab') { createSeriesForm?.classList.add('hidden'); }
             if (tabElement?.id === 'results-tab') { renderRaceResults(); } // Refresh results view if navigating to it

         }
        if(btnBoatList) btnBoatList.addEventListener('click', () => setActiveTab(boatListTab));
        if(btnSeries) btnSeries.addEventListener('click', () => setActiveTab(seriesTab));
        if(btnRace) btnRace.addEventListener('click', () => setActiveTab(raceTab));
        if(btnResults) btnResults.addEventListener('click', () => setActiveTab(resultsTab));
        if(btnSeriesResults) btnSeriesResults.addEventListener('click', () => { setActiveTab(seriesResultsTab); if (viewSeries?.value) calculateSeriesResults(); });
        if(btnRaceView) btnRaceView.addEventListener('click', () => { setActiveTab(raceViewTab); if (viewAllSeries?.value) displayRaceViewer(); });


        // --- Yardstick Functions ---
        function initYardsticks() {
            yardstickData.sort((a, b) => a.boatClass.localeCompare(b.boatClass));
            const populateSelect = (selectElement) => {
                 if (!selectElement) return;
                 selectElement.innerHTML = '<option value="">Select boat class</option>';
                 yardstickData.forEach(boat => {
                     const option = document.createElement('option');
                     option.value = boat.boatClass;
                     option.textContent = `${boat.boatClass} (${boat.yardstick})`;
                     selectElement.appendChild(option);
                 });
            }
            populateSelect(boatClassList);
        }

        // --- Boat List Functions ---
        function renderBoatListTable() {
            if (!boatListBody) return;
            boatListBody.innerHTML = '';
            boatList.sort((a, b) => {
                const sailComp = a.sailNumber.localeCompare(b.sailNumber, undefined, { numeric: true });
                if (sailComp !== 0) return sailComp;
                const skipperComp = a.skipper.localeCompare(b.skipper);
                if (skipperComp !== 0) return skipperComp;
                return a.boatClass.localeCompare(b.boatClass);
            });


             if (boatList.length === 0) {
                  const row = boatListBody.insertRow();
                  const cell = row.insertCell(); cell.colSpan = 5;
                  cell.textContent = 'No boats saved yet. Click "Add New Boat" to start.';
                  cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666';
                  return;
             }

            boatList.forEach(boat => {
                const row = boatListBody.insertRow();
                row.innerHTML = `
                    <td>${boat.sailNumber}</td>
                    <td>${boat.boatClass}</td>
                    <td>${boat.skipper}</td>
                    <td>${boat.yardstick}</td>
                    <td class="actions">
                        <button class="btn-edit" onclick="editBoatInList(${boat.id})">Edit</button>
                        <button class="btn-danger" onclick="deleteBoatFromList(${boat.id})">Delete</button>
                    </td>
                `;
            });
            populateSavedBoatDropdown();
        }
        function clearBoatListForm() {
            if (!boatListForm) return;
            if(boatSailNumber) boatSailNumber.value = '';
            if(boatClassList) boatClassList.value = '';
            if(boatSkipper) boatSkipper.value = '';
            if(boatYardstick) {
                boatYardstick.value = '';
                boatYardstick.readOnly = true; // Default to readOnly
            }
            if(boatManualBoatClass) boatManualBoatClass.value = '';
            if(editingBoatId) editingBoatId.value = '';
            if(boatManualClassCheck) boatManualClassCheck.checked = false;
            if(boatManualClassInput) boatManualClassInput.classList.add('hidden');
            if(boatClassList) boatClassList.disabled = false;
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            boatListForm.classList.add('hidden');
            if(boatClassList) boatClassList.dispatchEvent(new Event('change')); // To reset YS based on cleared class
        }
        if(showAddBoatFormBtn) showAddBoatFormBtn.addEventListener('click', () => {
            clearBoatListForm();
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            if(boatListForm) boatListForm.classList.remove('hidden');
            if(boatSailNumber) boatSailNumber.focus();
        });
        if(cancelBoatListBtn) cancelBoatListBtn.addEventListener('click', clearBoatListForm);

        if(saveBoatListBtn) saveBoatListBtn.addEventListener('click', async () => {
            console.log("Attempting to save boat...");
            const id = editingBoatId?.value ? parseInt(editingBoatId.value) : null;
            const sailNum = boatSailNumber?.value.trim().toUpperCase();
            const skipper = boatSkipper?.value.trim();
            const ysValue = parseFloat(boatYardstick?.value);
            const isManualClass = boatManualClassCheck?.checked;
            const boatClass = isManualClass ? boatManualBoatClass?.value.trim() : boatClassList?.value;

            if (!sailNum) { alert("Sail Number is required."); return; }
            if (!boatClass) { alert("Boat Class is required."); return; }
            if (!skipper) { alert("Skipper Name is required."); return; }
            if (isNaN(ysValue) || ysValue <= 0) { alert("Valid positive Yardstick is required."); return; }

            const boatData = { id: id || Date.now(), sailNumber: sailNum, boatClass: boatClass, skipper: skipper, yardstick: ysValue };

            if (id) {
                const index = boatList.findIndex(b => b.id === id);
                if (index !== -1) { boatList[index] = boatData; }
                else { alert("Error finding boat to update."); return; }
            } else {
                boatList.push(boatData);
            }

            await saveDataToGoogleSheet();
            renderBoatListTable();
            clearBoatListForm();
        });

        function editBoatInList(id) {
            const boat = boatList.find(b => b.id === id);
            if (!boat) return;
            clearBoatListForm(); // This will set boatYardstick.readOnly = true initially
            
            if(editingBoatId) editingBoatId.value = boat.id;
            if(boatSailNumber) boatSailNumber.value = boat.sailNumber;
            if(boatSkipper) boatSkipper.value = boat.skipper;
            if(boatYardstick) boatYardstick.value = boat.yardstick; // Set the value
            if(boatFormTitle) boatFormTitle.textContent = `Edit Boat: ${boat.sailNumber} - ${boat.skipper}`;

            const isStandardClassInList = yardstickData.some(yc => yc.boatClass === boat.boatClass);

            if (isStandardClassInList && boatClassList && boatClassList.querySelector(`option[value="${boat.boatClass}"]`)) {
                 if(boatManualClassCheck) boatManualClassCheck.checked = false;
                 if(boatClassList) boatClassList.value = boat.boatClass;
                 if(boatManualClassInput) boatManualClassInput.classList.add('hidden');
                 if(boatClassList) boatClassList.disabled = false;
                 if(boatManualBoatClass) boatManualBoatClass.value = '';

                 const selectedClassData = yardstickData.find(b => b.boatClass === boat.boatClass);
                 const autoYardstick = selectedClassData ? selectedClassData.yardstick : null;

                 if (autoYardstick !== null && boat.yardstick === autoYardstick) {
                     if(boatYardstick) boatYardstick.readOnly = true; // Matches standard
                 } else {
                     if(boatYardstick) boatYardstick.readOnly = false; // Custom YS for standard class
                 }
             } else { // Custom class name or class not in dropdown
                 if(boatManualClassCheck) boatManualClassCheck.checked = true;
                 if(boatManualBoatClass) boatManualBoatClass.value = boat.boatClass;
                 if(boatClassList) boatClassList.value = '';
                 if(boatManualClassInput) boatManualClassInput.classList.remove('hidden');
                 if(boatClassList) boatClassList.disabled = true;
                 if(boatYardstick) boatYardstick.readOnly = false; // Yardstick is manual for custom class
             }
            if(boatListForm) {
                boatListForm.classList.remove('hidden');
                boatListForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        async function deleteBoatFromList(id) {
            const boatIndex = boatList.findIndex(b => b.id === id);
            if (boatIndex === -1) return;
            const boat = boatList[boatIndex];
            if (confirm(`Are you sure you want to delete ${boat.sailNumber} (${boat.skipper}) from the saved boat list?`)) {
                boatList.splice(boatIndex, 1);
                await saveDataToGoogleSheet();
                renderBoatListTable();
            }
        }

        if(boatClassList) boatClassList.addEventListener('change', () => {
            const selectedClass = boatClassList.value;
            const isManualClassNameMode = boatManualClassCheck?.checked;

            if (!isManualClassNameMode) { // If class is being selected from dropdown
                if (selectedClass) { // A class is selected from dropdown
                    const boatData = yardstickData.find(boat => boat.boatClass === selectedClass);
                    if(boatYardstick) {
                        boatYardstick.value = boatData ? boatData.yardstick : '';
                        boatYardstick.readOnly = true; // Auto-filled, so readOnly
                    }
                } else { // "Select boat class" chosen, or dropdown is empty
                    if(boatYardstick) {
                        boatYardstick.value = '';
                        boatYardstick.readOnly = true; // No class, so YS is blank and readOnly
                    }
                }
            }
        });

        if(boatManualClassCheck) boatManualClassCheck.addEventListener('change', () => {
            const isManualClassEntry = boatManualClassCheck.checked;
            if(boatClassList) boatClassList.disabled = isManualClassEntry;
            if(boatManualClassInput) boatManualClassInput.classList.toggle('hidden', !isManualClassEntry);

            if (!isManualClassEntry) { 
                if(boatManualBoatClass) boatManualBoatClass.value = '';
                if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
            } else { 
                 if(boatYardstick) {
                    boatYardstick.value = ''; 
                    boatYardstick.readOnly = false; 
                 }
                 if(boatClassList) boatClassList.value = ''; 
                 if(boatManualBoatClass) boatManualBoatClass.focus();
            }
        });
        
        if(boatYardstick) {
            boatYardstick.addEventListener('focus', () => {
                const isManualClassEntry = boatManualClassCheck?.checked;
                if (!isManualClassEntry && boatYardstick) {
                    boatYardstick.readOnly = false;
                }
            });
        }


        // --- Race Entry Functions ---
        function populateSavedBoatDropdown() {
            if (!selectSavedBoat) return;
            const currentVal = selectSavedBoat.value;
            selectSavedBoat.innerHTML = '<option value="">-- Select Saved Boat --</option>';
            boatList.sort((a,b) => {
                const sailComp = a.sailNumber.localeCompare(b.sailNumber, undefined, { numeric: true });
                if (sailComp !== 0) return sailComp;
                const skipperComp = a.skipper.localeCompare(b.skipper);
                if (skipperComp !== 0) return skipperComp;
                return a.boatClass.localeCompare(b.boatClass);
            });
            boatList.forEach(boat => {
                const option = document.createElement('option');
                option.value = boat.id;
                option.textContent = `${boat.sailNumber} - ${boat.skipper} (${boat.boatClass} YS:${boat.yardstick})`;
                selectSavedBoat.appendChild(option);
            });
             if (boatList.some(b => b.id == currentVal)) { selectSavedBoat.value = currentVal; }
        }

        if(selectSavedBoat) selectSavedBoat.addEventListener('change', () => {
            const selectedBoatId = selectSavedBoat.value;
            if (selectedBoatId) {
                const boat = boatList.find(b => String(b.id) === String(selectedBoatId));
                if (boat && yardstickValue) {
                    yardstickValue.value = boat.yardstick;
                } else if (yardstickValue) {
                    yardstickValue.value = "";
                }
            } else if (yardstickValue) {
                yardstickValue.value = "";
            }
        });

        function clearEntryForm() {
             if(yardstickValue) yardstickValue.value = '';
             if(editingEntryIndexInput) editingEntryIndexInput.value = '-1';
             if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = '-1';
             if(addBoatBtn) addBoatBtn.style.display = 'inline-block';
             if(updateBoatBtn) updateBoatBtn.classList.add('hidden');
             if(cancelUpdateBtn) cancelUpdateBtn.classList.add('hidden');
             if(selectSavedBoat) selectSavedBoat.value = '';
             if(mainFormStatusGroup) mainFormStatusGroup.classList.add('hidden');
             if(timeInputs) timeInputs.classList.add('hidden');
         }


        function handleStatusChange() { 
            const selectedStatusRadio = document.querySelector('input[name="race-status"]:checked');
            if (!selectedStatusRadio) return; 
            const selectedStatus = selectedStatusRadio.value;

            if(timeInputs) timeInputs.style.display = (selectedStatus === 'finished' && !timeInputs.classList.contains('hidden')) ? 'block' : 'none';
            if (selectedStatus !== 'finished' && elapsedTime) elapsedTime.value = '';
        }
        statusRadios.forEach(radio => radio.addEventListener('change', handleStatusChange)); 

        if(addBoatBtn) addBoatBtn.addEventListener('click', () => {
            const entryData = getEntryFormData();
            if (!entryData) return;

            if (currentSeries?.isShortCourse) {
                if (entries.some(e => e.savedBoatId === entryData.savedBoatId)) {
                    alert(`Boat "${entryData.sailNumber} - ${entryData.skipper}" is already in the pool.`);
                    return;
                }
                entries.push(entryData);
                renderShortCoursePoolTable();
            } else {
                 if (!currentRace) { alert("Please select a race number before adding boats."); return; }
                if (entries.some(e => e.savedBoatId === entryData.savedBoatId)) {
                    alert(`Boat "${entryData.sailNumber} - ${entryData.skipper}" is already entered in this race.`);
                    return;
                }
                entries.push(entryData);
                renderEntriesTable();
            }
            if(selectSavedBoat) selectSavedBoat.value = "";
            if(yardstickValue) yardstickValue.value = "";
            if(selectSavedBoat) selectSavedBoat.focus();
        });
        
        function getBoatAndYardstickFromForm() { 
            const selectedBoatId = selectSavedBoat?.value;
            if (!selectedBoatId) {
                alert('Please select a boat from the dropdown.');
                return null;
            }
            const savedBoat = boatList.find(b => String(b.id) === String(selectedBoatId));
            if (!savedBoat) {
                alert('Selected boat not found in the boat list. Please refresh or check the boat list.');
                return null;
            }

            const currentYardstick = parseFloat(yardstickValue?.value);
            if (isNaN(currentYardstick) || currentYardstick <=0) {
                alert('Valid positive Yardstick is required.');
                if (yardstickValue) yardstickValue.focus();
                return null;
            }
            return {
                savedBoatId: savedBoat.id,
                sailNumber: savedBoat.sailNumber,
                boatClass: savedBoat.boatClass,
                skipper: savedBoat.skipper,
                yardstick: currentYardstick,
            };
        }


        if(updateBoatBtn) updateBoatBtn.addEventListener('click', () => {
            const index = parseInt(editingEntryIndexInput?.value);
            const shortCourseRaceIndex = parseInt(editingShortCourseRaceIndexInput?.value);

            if (currentSeries?.isShortCourse) {
                if (shortCourseRaceIndex >= 0 && shortCourseRaceIndex < shortCourseSessionRaces.length && index >= 0 && index < shortCourseSessionRaces[shortCourseRaceIndex].entries.length) {
                    const boatDetails = getBoatAndYardstickFromForm();
                    if (!boatDetails) return;

                    const targetEntry = shortCourseSessionRaces[shortCourseRaceIndex].entries[index];
                     if (shortCourseSessionRaces[shortCourseRaceIndex].entries.some((e, i) => i !== index && e.savedBoatId === boatDetails.savedBoatId && e.yardstick === boatDetails.yardstick)) {
                        alert(`Boat "${boatDetails.sailNumber} - ${boatDetails.skipper}" (or identical entry) is already entered in this race.`);
                        return;
                    }
                    targetEntry.savedBoatId = boatDetails.savedBoatId;
                    targetEntry.sailNumber = boatDetails.sailNumber;
                    targetEntry.boatClass = boatDetails.boatClass;
                    targetEntry.skipper = boatDetails.skipper;
                    targetEntry.yardstick = boatDetails.yardstick;
                    
                    const mainFormData = getEntryFormData(); 
                    if (!mainFormData && (document.querySelector('input[name="race-status"]:checked')?.value === 'finished')) {
                        return; 
                    }
                    
                    if (mainFormData) {
                        targetEntry.status = mainFormData.status;
                        targetEntry.elapsedTime = mainFormData.elapsedTime; // Raw valid time
                    } else if (document.querySelector('input[name="race-status"]:checked')?.value !== 'finished') {
                        targetEntry.status = document.querySelector('input[name="race-status"]:checked')?.value;
                        targetEntry.elapsedTime = '';
                    } else {
                        console.error("Update short course: Could not get valid data from form.");
                        return;
                    }
                    renderShortCourseSessionRaces();

                } else if (shortCourseRaceIndex === -1 && index >= 0 && index < entries.length) { 
                    const entryData = getEntryFormData(); 
                    if (!entryData) return;
                    if (entries.some((e, i) => i !== index && e.savedBoatId === entryData.savedBoatId)) {
                        alert(`Boat "${entryData.sailNumber} - ${entryData.skipper}" is already in the pool.`);
                        return;
                    }
                    entries[index] = entryData;
                    renderShortCoursePoolTable();
                }
                 else { alert('Error updating short course entry. Index out of bounds.'); }
            } else { 
                 const entryData = getEntryFormData(); 
                 if (!entryData) return;
                if (!currentRace) { alert("Error: No standard race selected for update."); return; }
                if (index >= 0 && index < entries.length) {
                    if (entries.some((e, i) => i !== index && e.savedBoatId === entryData.savedBoatId && e.yardstick === entryData.yardstick)) {
                        alert(`Boat "${entryData.sailNumber} - ${entryData.skipper}" (or identical entry) is already entered in this race.`);
                        return;
                    }
                    entries[index].savedBoatId = entryData.savedBoatId;
                    entries[index].sailNumber = entryData.sailNumber;
                    entries[index].boatClass = entryData.boatClass;
                    entries[index].skipper = entryData.skipper;
                    entries[index].yardstick = entryData.yardstick;
                    renderEntriesTable();
                } else { alert('Error updating standard entry. Index out of bounds.'); }
            }
            clearEntryForm();
            if (currentSeries?.isShortCourse) switchToShortCourseUI(); else switchToStandardRaceUI();
        });


        if(cancelUpdateBtn) cancelUpdateBtn.addEventListener('click', () => {
            clearEntryForm();
            if (currentSeries?.isShortCourse) {
                if(editingShortCourseRaceIndexInput?.value !== '-1') { 
                }
                switchToShortCourseUI(); 
            } else {
                switchToStandardRaceUI();
            }
        });

        function getEntryFormData() {
            const selectedBoatId = selectSavedBoat?.value;
            if (!selectedBoatId) {
                alert('Please select a boat from the dropdown.');
                return null;
            }
            const savedBoat = boatList.find(b => String(b.id) === String(selectedBoatId));
            if (!savedBoat) {
                alert('Selected boat not found in the boat list. Please refresh or check the boat list.');
                return null;
            }

            const currentYardstick = parseFloat(yardstickValue?.value);
            if (isNaN(currentYardstick) || currentYardstick <=0) {
                alert('Valid positive Yardstick is required.');
                if (yardstickValue) yardstickValue.focus();
                return null;
            }

            let status = 'finished'; 
            let elapsed = ''; // This will store the raw valid time string or be empty    

            const inStandardRaceContext = standardEntryFields && !standardEntryFields.classList.contains('hidden');
            const mainFormStatusTimeActive = mainFormStatusGroup && !mainFormStatusGroup.classList.contains('hidden');


            if (inStandardRaceContext && !mainFormStatusTimeActive) { 
                 status = 'finished'; 
                 elapsed = '';
            } else if (mainFormStatusTimeActive) { 
                 status = document.querySelector('input[name="race-status"]:checked')?.value;
                 let rawElapsed = elapsedTime?.value.trim();
                 if (!status) { alert('Race Status required from form.'); return null; }
                 if (status === 'finished') { 
                     if (rawElapsed) {
                         const seconds = timeToSeconds(rawElapsed);
                         if (seconds === -1) { 
                             alert('Invalid time format in form. Use h:m:s, h m s, m:s, or m s (e.g., 1:30:45, 1 30 45, 30:45, or 30 45).'); return null; 
                         }
                         elapsed = rawElapsed; // Store raw valid time
                     } else {
                         alert('Elapsed time is required for finished status from form.'); return null;
                     }
                 }
                 else { elapsed = ''; }
            }
            else { 
                status = 'pool';
                elapsed = '';
            }


            return {
                savedBoatId: savedBoat.id,
                sailNumber: savedBoat.sailNumber,
                boatClass: savedBoat.boatClass,
                skipper: savedBoat.skipper,
                yardstick: currentYardstick,
                status,
                elapsedTime: elapsed 
            };
        }
        
        function updateStandardEntryInTable(index, field, value) {
            if (index < 0 || index >= entries.length) {
                console.error("Invalid index for updateStandardEntryInTable"); return;
            }
            const entry = entries[index];
            const row = entriesBody.querySelector(`tr[data-entry-index="${index}"]`);
            const timeInputInTable = row?.querySelector('.table-entry-input');

            if (field === 'elapsedTime' && entry.status === 'finished') {
                if (value.trim() === '') { 
                    entry.elapsedTime = '';
                } else if (isValidTimeFormat(value)) { 
                    entry.elapsedTime = value.trim(); // Store raw valid time
                    // DO NOT reformat timeInputInTable.value here
                } else { 
                    entry.elapsedTime = value; 
                    console.warn("Invalid time format entered in table:", value, ". Use h:m:s, h m s, m:s, or m s.");
                }
            } else if (field === 'status') {
                entry.status = value; 
                if (timeInputInTable) {
                    timeInputInTable.disabled = (entry.status !== 'finished');
                    if (entry.status !== 'finished') {
                        timeInputInTable.value = '';
                        entry.elapsedTime = ''; 
                    }
                }
            } else {
                 entry[field] = value;
            }
        }


        function renderEntriesTable() { 
            if (!entriesBody) return;
            entriesBody.innerHTML = '';
             const raceNumText = currentRace ? ` Race ${currentRace}` : '';
             if(currentEntriesHeading) currentEntriesHeading.textContent = `Entries${raceNumText}`;

            if (entries.length === 0) {
                const row = entriesBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 7; cell.textContent = currentRace ? 'No entries added yet for this race.' : 'Select a race to view/add entries.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = entriesBody.insertRow();
                row.dataset.entryIndex = index; 

                const statusOptions = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD']
                    .map(s => `<option value="${s}" ${entry.status === s ? 'selected' : ''}>${s.toUpperCase()}</option>`)
                    .join('');

                row.innerHTML = `
                    <td>${entry.sailNumber}</td>
                    <td>${entry.boatClass}</td>
                    <td>${entry.skipper}</td>
                    <td>${entry.yardstick}</td>
                    <td>
                        <select class="table-entry-select" onchange="updateStandardEntryInTable(${index}, 'status', this.value)">
                            ${statusOptions}
                        </select>
                    </td>
                    <td>
                        <input type="text" class="table-entry-input" value="${entry.elapsedTime || ''}" placeholder="h:m:s / m:s / etc." 
                               oninput="updateStandardEntryInTable(${index}, 'elapsedTime', this.value)" 
                               ${entry.status !== 'finished' ? 'disabled' : ''}>
                    </td>
                    <td class="actions">
                        <button class="btn-danger" onclick="removeEntry(${index})">Rem</button>
                    </td>`;
            });
        }

        function renderShortCoursePoolTable() {
            if (!shortCoursePoolBody) return;
            shortCoursePoolBody.innerHTML = '';
             const poolCount = entries.length;
             if(shortCoursePoolHeading) shortCoursePoolHeading.textContent = `Race Entries (${poolCount} ${pluralize(poolCount, 'Boat')})`;

            if (poolCount === 0) {
                const row = shortCoursePoolBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 5; cell.textContent = 'Add boats using the form above to create the pool for the next race.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = shortCoursePoolBody.insertRow();
                row.innerHTML = `<td>${entry.sailNumber}</td><td>${entry.boatClass}</td><td>${entry.skipper}</td><td>${entry.yardstick}</td><td class="actions"><button class="btn-edit" onclick="editEntry(${index})">Edit</button><button class="btn-danger" onclick="removeEntry(${index})">Rem</button></td>`;
            });
        }

        function editEntry(index) { 
            let entry;
            clearEntryForm();

            if (currentSeries?.isShortCourse) { 
                 if (index >= 0 && index < entries.length) {
                     entry = entries[index];
                 } else { return; }
                 if (editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = -1; 
                 if(mainFormStatusGroup) mainFormStatusGroup.classList.add('hidden');
                 if(timeInputs) timeInputs.classList.add('hidden');
                 if (entryFormTitle) entryFormTitle.textContent = "Edit Boat in Pool";

            } else { 
                 console.warn("editEntry called for standard series, but table edit button is removed.");
                 return;
            }

            if (!entry) return;

            if(selectSavedBoat && entry.savedBoatId) {
                selectSavedBoat.value = entry.savedBoatId;
            } else if (selectSavedBoat) {
                selectSavedBoat.value = "";
            }
            if(yardstickValue) yardstickValue.value = entry.yardstick;

            if(editingEntryIndexInput) editingEntryIndexInput.value = index;

            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden');
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden');
            if(selectSavedBoat) { selectSavedBoat.focus(); selectSavedBoat.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }

        function editShortCourseEntry(raceIndex, entryIndex) { 
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for editShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (!entry) return;

            clearEntryForm(); 

            if(selectSavedBoat && entry.savedBoatId) {
                selectSavedBoat.value = entry.savedBoatId;
            } else if (selectSavedBoat) {
                selectSavedBoat.value = "";
            }
            if(yardstickValue) yardstickValue.value = entry.yardstick;

            if(editingEntryIndexInput) editingEntryIndexInput.value = entryIndex;
            if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = raceIndex;

            if(mainFormStatusGroup) mainFormStatusGroup.classList.remove('hidden');
            if(elapsedTime) elapsedTime.value = entry.elapsedTime || ''; 
            try {
                const statusRadio = document.getElementById(`status-${entry.status.toLowerCase()}`);
                if(statusRadio) statusRadio.checked = true; else document.getElementById('status-finished').checked = true;
                handleStatusChange(); 
            } catch (e) { console.warn("Status ID not found for SC entry:", entry.status); if(document.getElementById('status-finished')) document.getElementById('status-finished').checked = true; handleStatusChange(); }
            
            if (standardEntryFields) standardEntryFields.classList.remove('hidden'); 
            if (entryFormTitle) entryFormTitle.textContent = `Edit Entry in SC Race ${raceIndex + 1}`;


            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden');
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden');
            if(selectSavedBoat) { selectSavedBoat.focus(); selectSavedBoat.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }


        function removeEntry(index) {
            let targetArray;
            let renderFunction;

            if (currentSeries?.isShortCourse) {
                targetArray = entries; 
                renderFunction = renderShortCoursePoolTable;
            } else { 
                 if (!currentRace) { console.error("Attempting to remove standard entry with no race selected."); return; }
                targetArray = entries;
                renderFunction = renderEntriesTable;
            }

            if (index < 0 || index >= targetArray.length) return;
            if (confirm(`Remove entry for ${targetArray[index]?.sailNumber || 'this boat'}?`)) {
                targetArray.splice(index, 1);
                renderFunction(); 
                 if (currentSeries?.isShortCourse && editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === index && editingShortCourseRaceIndexInput && parseInt(editingShortCourseRaceIndexInput.value) === -1) {
                    clearEntryForm(); 
                    switchToShortCourseUI();
                } else if (!currentSeries?.isShortCourse) {
                }
            }
        }

         function removeShortCourseEntry(raceIndex, entryIndex) {
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for removeShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (confirm(`Remove entry for ${entry?.sailNumber || 'this boat'} from Race ${raceIndex + 1}?`)) {
                shortCourseSessionRaces[raceIndex].entries.splice(entryIndex, 1);
                renderShortCourseSessionRaces();
                 if (editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === entryIndex && editingShortCourseRaceIndexInput && parseInt(editingShortCourseRaceIndexInput.value) === raceIndex) {
                    clearEntryForm(); 
                 }
            }
         }


        if(clearAllBtn) clearAllBtn.addEventListener('click', () => {
            if (currentSeries?.isShortCourse) {
                if (entries.length === 0) { alert("Boat pool is already empty."); return; }
                if (confirm('Clear all boats from the Race Entries? (Does not affect created races).')) {
                    entries = [];
                    renderShortCoursePoolTable();
                    clearEntryForm();
                }
            } else {
                 if (!currentRace) { alert("Please select a race before clearing entries."); return; }
                if (entries.length === 0) { alert("Entry list is already empty for this race."); return; }
                if (confirm(`Clear all current entries in this list for Race ${currentRace}? (Does not affect saved data).`)) {
                    entries = [];
                    renderEntriesTable();
                    clearEntryForm();
                }
            }
        });
        if(clearFormBtn) clearFormBtn.addEventListener('click', () => {
             clearEntryForm(); 
             if (currentSeries?.isShortCourse) {
                if(editingShortCourseRaceIndexInput?.value !== '-1') { 
                     if(entryFormTitle) entryFormTitle.textContent = "Add Boat to Entries"; 
                }
                switchToShortCourseUI(); 
             } else {
                 switchToStandardRaceUI();
             }
        });

        if (createShortCourseRaceBtn) createShortCourseRaceBtn.addEventListener('click', () => {
            if (entries.length === 0) {
                alert("The 'Race Entries' is empty. Add boats before creating a race.");
                return;
            }
            if (!currentSeries || !currentSeries.isShortCourse) {
                 alert("Error: Cannot create short course race - current series is not set or not a short course series.");
                 return;
            }
            const nextRaceNumber = shortCourseSessionRaces.length + 1;
            const raceEntries = JSON.parse(JSON.stringify(entries)).map(entry => ({
                ...entry,
                status: 'finished', 
                elapsedTime: '' // Raw times from pool, will be populated in table
            }));
            shortCourseSessionRaces.push({
                raceNumber: nextRaceNumber,
                entries: raceEntries
            });
            renderShortCourseSessionRaces();
            updateCreateRaceButton();
            updateRemoveLastRaceButtonVisibility();
        });
        
        function handleRemoveLastShortCourseRace() {
            if (shortCourseSessionRaces.length === 0) {
                alert("No created races to remove.");
                return;
            }
            const lastRaceNumber = shortCourseSessionRaces.length;
            if (confirm(`Are you sure you want to remove the last created race (Race ${lastRaceNumber})? This cannot be undone.`)) {
                const removedRaceIndex = shortCourseSessionRaces.length - 1;
                shortCourseSessionRaces.pop();
                renderShortCourseSessionRaces();
                updateCreateRaceButton();
                updateRemoveLastRaceButtonVisibility();

                const editingScRaceIdx = parseInt(editingShortCourseRaceIndexInput?.value);
                if (editingScRaceIdx === removedRaceIndex) {
                    clearEntryForm(); 
                    if (entryFormTitle) entryFormTitle.textContent = "Add Boat to Entries";
                }
            }
        }
        if (removeLastShortCourseRaceBtn) removeLastShortCourseRaceBtn.addEventListener('click', handleRemoveLastShortCourseRace);

        function updateRemoveLastRaceButtonVisibility() {
            if (removeLastShortCourseRaceBtn) {
                removeLastShortCourseRaceBtn.classList.toggle('hidden', shortCourseSessionRaces.length === 0);
            }
        }


        function renderShortCourseSessionRaces() {
            if (!shortCourseRacesContainer) return;
            shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3>';

            if (shortCourseSessionRaces.length === 0) {
                 shortCourseRacesContainer.innerHTML += '<p>No races created yet in this session.</p>';
                 return;
            }
            shortCourseSessionRaces.forEach((raceData, raceIndex) => {
                const raceSection = document.createElement('div');
                raceSection.classList.add('short-course-race-section');
                raceSection.dataset.raceIndex = raceIndex;
                let tableHTML = `<h4>Race ${raceData.raceNumber} (${raceData.entries.length} ${pluralize(raceData.entries.length, 'Boat')})</h4>
                    <div style="overflow-x: auto;">
                    <table class="short-course-race-table">
                        <thead>
                            <tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr>
                        </thead>
                        <tbody>`;
                raceData.entries.forEach((entry, entryIndex) => {
                    const statusOptions = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD']
                        .map(s => `<option value="${s}" ${entry.status === s ? 'selected' : ''}>${s.toUpperCase()}</option>`)
                        .join('');
                    tableHTML += `
                        <tr data-entry-index="${entryIndex}">
                            <td>${entry.sailNumber}</td>
                            <td>${entry.boatClass}</td>
                            <td>${entry.skipper}</td>
                            <td>${entry.yardstick}</td>
                            <td class="short-course-race-entry">
                                <select class="sc-status-select" onchange="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'status', this.value)">
                                    ${statusOptions}
                                </select>
                            </td>
                            <td class="short-course-race-entry">
                                <input type="text" class="sc-time-input" value="${entry.elapsedTime || ''}" placeholder="h:m:s / m:s / etc." oninput="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'elapsedTime', this.value)" ${entry.status !== 'finished' ? 'disabled' : ''}>
                            </td>
                            <td class="actions">
                                <button class="btn-edit" onclick="editShortCourseEntry(${raceIndex}, ${entryIndex})">Edit</button>
                                <button class="btn-danger" onclick="removeShortCourseEntry(${raceIndex}, ${entryIndex})">Rem</button>
                            </td>
                        </tr>`;
                });
                tableHTML += `</tbody></table></div>`;
                raceSection.innerHTML = tableHTML;
                shortCourseRacesContainer.appendChild(raceSection);
            });
        }

        function updateShortCourseEntry(raceIndex, entryIndex, field, value) {
            if (raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for updateShortCourseEntry"); return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            const raceSectionDiv = shortCourseRacesContainer.querySelector(`div[data-race-index="${raceIndex}"]`);
            const row = raceSectionDiv?.querySelector(`tr[data-entry-index="${entryIndex}"]`);
            const timeInputInTable = row?.querySelector('.sc-time-input');

            if (field === 'elapsedTime' && entry.status === 'finished') {
                if (value.trim() === '') { 
                    entry.elapsedTime = '';
                } else if (isValidTimeFormat(value)) { 
                    entry.elapsedTime = value.trim(); // Store raw valid time
                    // DO NOT reformat timeInputInTable.value here
                } else { 
                    entry.elapsedTime = value; 
                    console.warn("Invalid time format entered in SC table:", value, ". Use h:m:s, h m s, m:s, or m s.");
                }
            } else if (field === 'status') {
                entry.status = value; 
                if (timeInputInTable) {
                    timeInputInTable.disabled = (entry.status !== 'finished');
                    if (entry.status !== 'finished') {
                        timeInputInTable.value = '';
                        entry.elapsedTime = '';
                    }
                }
            } else {
                 entry[field] = value;
            }
        }

        function updateCreateRaceButton() {
            if (createShortCourseRaceBtn) {
                const nextRaceNum = shortCourseSessionRaces.length + 1;
                createShortCourseRaceBtn.textContent = `Create Race ${nextRaceNum}`;
            }
        }

        function clearShortCourseSessionData() {
            shortCourseSessionRaces = [];
            if (shortCourseRacesContainer) shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3><p>No races created yet in this session.</p>';
            updateCreateRaceButton();
            updateRemoveLastRaceButtonVisibility();
        }
         if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.addEventListener('click', () => {
            if (shortCourseSessionRaces.length === 0) {
                 alert("There are no created races in this session to clear.");
                 return;
            }
            if (confirm(`Are you sure you want to clear the ${shortCourseSessionRaces.length} ${pluralize(shortCourseSessionRaces.length, 'race')} created in this session? This cannot be undone.`)) {
                clearShortCourseSessionData();
            }
         });


        if(calculateResultsBtn) calculateResultsBtn.addEventListener('click', async () => {
            if (currentSeries?.isShortCourse) {
                 if (shortCourseSessionRaces.length === 0) {
                    alert("No races have been created in this session. Use the 'Create Race N' button first.");
                    return;
                 }
                 if (!currentSeries) {
                     alert("Error: No series selected."); return;
                 }
                
                 for (const sessionRaceData of shortCourseSessionRaces) {
                    const invalidTimeEntry = sessionRaceData.entries.find(e => 
                        e.status === 'finished' && 
                        e.elapsedTime && 
                        timeToSeconds(e.elapsedTime) === -1 
                    );
                    if (invalidTimeEntry) {
                        alert(`Invalid time format for ${invalidTimeEntry.sailNumber} in Race ${sessionRaceData.raceNumber} of the created races. Please correct before calculating. Use h:m:s, h m s, m:s, or m s (e.g., 1:30:45, 1 30 45, 30:45, or 30 45).`);
                        return;
                    }
                     const missingTimeEntry = sessionRaceData.entries.find(e => e.status === 'finished' && !e.elapsedTime);
                     if (missingTimeEntry) {
                         alert(`Missing elapsed time for ${missingTimeEntry.sailNumber} (finished) in Race ${sessionRaceData.raceNumber} of the created races. Please enter a time or change status.`);
                         return;
                     }
                 }


                 if (!confirm(`This will calculate results for the ${shortCourseSessionRaces.length} created ${pluralize(shortCourseSessionRaces.length, 'race', 'races')} and save them permanently to the series "${currentSeries.name}". Are you sure you want to proceed?`)) {
                    return; 
                 }

                 console.log(`Calculating and saving ${shortCourseSessionRaces.length} short course races for series: ${currentSeries.name}`);
                 try {
                     let racesAddedCount = 0;
                     const seriesToUpdate = series.find(s => s.id === currentSeries.id);
                     if (!seriesToUpdate) throw new Error("Could not find the series in the main data array.");

                     const maxExistingRaceNum = seriesToUpdate.races.reduce((max, race) => Math.max(max, race.raceNumber), 0);
                     let nextRaceNum = maxExistingRaceNum + 1;

                     for (const sessionRaceData of shortCourseSessionRaces) {
                         const calculatedResults = calculateSingleRaceResults(sessionRaceData.entries, seriesToUpdate); 
                         
                         // Derive entriesForSaving from calculatedResults to ensure standardized times in saved entries
                         const entriesForSaving = calculatedResults.map(cr => ({
                             savedBoatId: cr.savedBoatId,
                             sailNumber: cr.sailNumber,
                             boatClass: cr.boatClass,
                             skipper: cr.skipper,
                             yardstick: cr.yardstick,
                             status: cr.status,
                             elapsedTime: cr.elapsedTime // This is standardized by calculateSingleRaceResults
                         }));

                         const raceToSave = {
                             raceNumber: nextRaceNum,
                             date: new Date().toISOString().split('T')[0],
                             entries: entriesForSaving, 
                             results: calculatedResults
                         };
                         seriesToUpdate.races.push(raceToSave);
                         racesAddedCount++;
                         nextRaceNum++;
                     }
                     seriesToUpdate.numberOfRaces = seriesToUpdate.races.length; 
                     seriesToUpdate.races.sort((a, b) => a.raceNumber - b.raceNumber);

                     await saveDataToGoogleSheet();

                     const seriesIdJustUpdated = seriesToUpdate.id;
                     clearShortCourseSessionData();
                     refreshSeriesDropdowns();
                     refreshSeriesList();
                     alert(`${racesAddedCount} ${pluralize(racesAddedCount, 'race')} added and saved to series "${seriesToUpdate.name}".`);
                     setActiveTab(raceViewTab);
                     if(viewAllSeries) viewAllSeries.value = seriesIdJustUpdated;
                     displayRaceViewer();
                 } catch (error) {
                     console.error("Error calculating or saving short course races:", error);
                     alert("Error: " + error.message);
                 }
            } else { // Standard Race Calculation & IMMEDIATE SAVE
                if (entries.length === 0) { alert('Add at least one boat entry first.'); return; }
                if (!currentSeries || typeof currentRace !== 'number') { 
                    alert("Select a series and race number first."); return;
                }
                const invalidTimeStandardEntry = entries.find(e => e.status === 'finished' && e.elapsedTime && timeToSeconds(e.elapsedTime) === -1);
                if (invalidTimeStandardEntry) {
                    alert(`Invalid time format for ${invalidTimeStandardEntry.sailNumber} in the current entries list. Please correct before calculating. Use h:m:s, h m s, m:s, or m s (e.g., 1:30:45, 1 30 45, 30:45, or 30 45).`);
                    return;
                }
                const missingTimeStandardEntry = entries.find(e => e.status === 'finished' && !e.elapsedTime);
                if (missingTimeStandardEntry) {
                    alert(`Missing elapsed time for ${missingTimeStandardEntry.sailNumber} (finished) in the current entries list. Please enter a time or change status.`);
                    return;
                }

                if (!confirm(`This will calculate results for Race ${currentRace} in series "${currentSeries.name}" and save them permanently. Are you sure you want to proceed?`)) {
                    return;
                }

                const newlyCalculatedResults = calculateSingleRaceResults(entries, currentSeries, currentRace); 

                // --- Start: Saving logic ---
                const seriesId = currentSeries.id;
                const raceNum = currentRace;

                const targetSeries = series.find(s => s.id === seriesId); 
                if (!targetSeries) { alert("Error: Series not found in application data for saving."); return; }

                const raceIndex = targetSeries.races.findIndex(race => race.raceNumber === raceNum); 
                if (raceIndex === -1) { alert(`Error: Race ${raceNum} not found in series "${targetSeries.name}" for saving.`); return; }

                const existingSavedResults = targetSeries.races[raceIndex].results;
                if (existingSavedResults && existingSavedResults.length > 0 && newlyCalculatedResults.length > 0) {
                    if (!confirm(`Race ${raceNum} already has saved results. Overwrite with these new calculations?`)) {
                         return; 
                    }
                }


                const resultsToSave = JSON.parse(JSON.stringify(newlyCalculatedResults)); 
                const entriesToSave = resultsToSave.map(res => ({
                    savedBoatId: res.savedBoatId,
                    sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper,
                    yardstick: res.yardstick,
                    status: res.status, elapsedTime: res.elapsedTime || '' 
                }));
                let dateToSave = targetSeries.races[raceIndex].date || new Date().toISOString().split('T')[0];

                try {
                    targetSeries.races[raceIndex].date = dateToSave;
                    targetSeries.races[raceIndex].entries = entriesToSave; 
                    targetSeries.races[raceIndex].results = resultsToSave;

                    await saveDataToGoogleSheet();

                    editMode = false; 
                    if(editModeWarning) editModeWarning.classList.add('hidden');
                    alert(`Race ${raceNum} results calculated and saved successfully for series "${targetSeries.name}".`);
                    
                    refreshSeriesDropdowns(); 
                    
                    results = resultsToSave; 

                    setActiveTab(resultsTab); 

                } catch (error) { 
                    console.error("Error saving race results from Race Entry tab:", error); 
                    alert("Error saving race results: " + error.message); 
                    return; 
                }
                // --- End: Saving logic ---
            }
        });

        function calculateSingleRaceResults(raceEntries, targetSeries, raceNumberForOOD = null) {
             if (!raceEntries || raceEntries.length === 0) return [];
             let calculated = JSON.parse(JSON.stringify(raceEntries)); // Deep copy
             calculated.forEach(result => {
                 let rawElapsedTime = result.elapsedTime || ''; // Use raw time from input
                 result.elapsedTime = ''; // Will be set to standardized format if finished and valid

                 if (result.status === 'finished') {
                     if (rawElapsedTime.length > 0) {
                         const elapsedSeconds = timeToSeconds(rawElapsedTime);
                         if (elapsedSeconds >= 0) { // Valid parse
                             result.elapsedTime = secondsToTime(elapsedSeconds); // Standardize format here for the result object
                             if (result.yardstick && result.yardstick > 0) {
                                 const correctedSeconds = elapsedSeconds * 100 / result.yardstick;
                                 result.correctedSeconds = correctedSeconds;
                                 result.correctedTime = secondsToTime(correctedSeconds);
                             } else {
                                 result.correctedSeconds = Infinity; result.correctedTime = 'Error: YS';
                             }
                         } else { // elapsedSeconds === -1, parsing failed
                              result.correctedSeconds = Infinity; result.correctedTime = 'Error: TimeFmt';
                              result.elapsedTime = rawElapsedTime; // Keep raw invalid time for display if needed
                         }
                     } else { // Elapsed time string is empty for a finished boat
                          result.correctedSeconds = Infinity; result.correctedTime = 'Error: NoTime';
                     }
                 } else {
                     result.correctedSeconds = null; result.correctedTime = null;
                 }
             });
             calculated.sort((a, b) => {
                 const statusOrder = { finished: 0, OOD: 1, DNF: 2, DSQ: 3, OCS: 4, DNS: 5 };
                 const statusA = statusOrder[a.status] ?? 99;
                 const statusB = statusOrder[b.status] ?? 99;
                 if (statusA !== statusB) return statusA - statusB;
                 if (a.status === 'finished') {
                     const correctedA = a.correctedSeconds ?? Infinity;
                     const correctedB = b.correctedSeconds ?? Infinity;
                     return correctedA - correctedB;
                 }
                 return 0;
             });
             let position = 1;
             let nonFinishersScore;
             const dncRule = targetSeries?.dncScoringRule || 'raceEntries';
             if (dncRule === 'raceEntries') {
                 nonFinishersScore = calculated.length + 1;
             } else {
                 const allCompetitorsInSeries = new Set();
                 targetSeries?.races?.forEach(r => {
                     if (r.results) r.results.forEach(res => allCompetitorsInSeries.add(res.sailNumber));
                     else if (r.entries) r.entries.forEach(ent => allCompetitorsInSeries.add(ent.sailNumber));
                 });
                 raceEntries.forEach(e => allCompetitorsInSeries.add(e.sailNumber));
                 nonFinishersScore = allCompetitorsInSeries.size + 1;
             }
             calculated.forEach((result, i) => {
                 if (result.status === 'finished') {
                     if (result.correctedSeconds === null || result.correctedSeconds === Infinity) {
                         result.position = 'Error';
                     } else if (i > 0 && calculated[i-1].status === 'finished' &&
                         typeof result.correctedSeconds === 'number' && typeof calculated[i-1].correctedSeconds === 'number' &&
                         result.correctedSeconds === calculated[i-1].correctedSeconds) {
                          result.position = calculated[i-1].position;
                     } else {
                         result.position = position;
                     }
                      if (result.position !== 'Error' && (i === 0 || result.position !== calculated[i-1].position || calculated[i-1].position === 'Error')) {
                           position++;
                      }
                 } else {
                     result.position = result.status.toUpperCase();
                 }
             });
             calculated.forEach(result => {
                 if (result.status === 'finished') {
                    if (typeof result.position === 'number') {
                        result.points = result.position;
                    } else {
                        result.points = nonFinishersScore;
                    }
                 } else if (['DNF', 'DNS', 'OCS', 'DSQ'].includes(result.status)) {
                     result.points = nonFinishersScore;
                 } else if (result.status === 'OOD') {
                     result.points = calculateOODPoints(result.sailNumber, calculated, targetSeries, raceNumberForOOD);
                 } else {
                     result.points = null;
                 }
             });
             return calculated;
         }

        function calculateOODPoints(sailNo, currentRaceCalculatedResults, targetSeries, oodRaceNumber) {
            const finishersInCurrentRace = currentRaceCalculatedResults.filter(r => r.status === 'finished' && typeof r.points === 'number');
            let oodPointsForThisRace = 0; // Default to 0 if no finishers

            if (finishersInCurrentRace.length > 0) {
                const avgFinisherPoints = finishersInCurrentRace.reduce((sum, r) => sum + r.points, 0) / finishersInCurrentRace.length;
                oodPointsForThisRace = Math.round(avgFinisherPoints * 10) / 10;
            }
            return oodPointsForThisRace;
         }


        // --- Race Results Tab Functions ---
        function renderRaceResults() {
            if (!resultsBody || !resultRaceInfo) return;
            resultsBody.innerHTML = '';

            const fixedMessage = `<p style="margin-top: 10px;">Results have been calculated. Please review them carefully. If anything is incorrect, return to the Race Entry page and make the necessary updates.</p>`;

            if (!currentSeries || typeof currentRace !== 'number') {
                resultRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race Information</h3><p>No results calculated or loaded. Please go to the Race Entry tab.</p></div>`;
                const row = resultsBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 9;
                cell.textContent = 'Please calculate or load results first.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666';
                return;
            }
            
            const seriesNameDisplay = currentSeries.name;
            const raceNumberDisplay = currentRace;

            resultRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race Information</h3><p><strong>Series:</strong> ${seriesNameDisplay}</p><p><strong>Race Number:</strong> ${raceNumberDisplay}</p><p><strong>Entries Shown:</strong> ${results?.length || 0}</p></div>` + fixedMessage;

            if (!results || results.length === 0) {
                 const existingInfoHTML = resultRaceInfo.innerHTML; 
                 // resultRaceInfo.innerHTML = existingInfoHTML; // Message already includes "Entries Shown: 0"
                 const row = resultsBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 9;
                 cell.textContent = 'No results to display for this race.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            results.forEach((result, index) => {
                const row = resultsBody.insertRow(); row.dataset.index = index;
                row.innerHTML = `
                    <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                    <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                    <td>${result.points ?? '-'}</td>`;
            });
        }

        // saveResultsTabBtn related functions and event listeners are removed as the button is gone.

        // --- Series Management ---
        if (seriesShortCourseCheck) seriesShortCourseCheck.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            if (standardSeriesOptions) standardSeriesOptions.classList.toggle('hidden', isChecked);
            if (shortCourseDiscardOptionsDiv) {
                shortCourseDiscardOptionsDiv.classList.toggle('hidden', !isChecked);
                if (!isChecked && seriesShortCourseDiscard5Check) {
                    seriesShortCourseDiscard5Check.checked = false; 
                }
            }
            if (dncScoringOptionsGroup) dncScoringOptionsGroup.classList.toggle('hidden', isChecked);
        });

        if(createSeriesBtn) createSeriesBtn.addEventListener('click', () => {
            if(seriesName) seriesName.value = '';
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = false;
            if(shortCourseDiscardOptionsDiv) shortCourseDiscardOptionsDiv.classList.add('hidden');
            if(seriesShortCourseDiscard5Check) seriesShortCourseDiscard5Check.checked = false;
            if(standardSeriesOptions) standardSeriesOptions.classList.remove('hidden');
            if(dncScoringOptionsGroup) dncScoringOptionsGroup.classList.remove('hidden'); 
            if(numberOfRaces) numberOfRaces.value = '8';
            if(racesPerDiscardInput) racesPerDiscardInput.value = '4';
            if(editSeriesId) editSeriesId.value = '';
            const defaultDncRadio = document.getElementById('dnc-rule-race');
            if(defaultDncRadio) defaultDncRadio.checked = true;
            if(createSeriesForm) createSeriesForm.classList.remove('hidden');
        });

        if(saveSeriesBtn) saveSeriesBtn.addEventListener('click', async () => {
            const name = seriesName?.value.trim();
            const isShortCourse = seriesShortCourseCheck?.checked || false;
            const shortCourseDiscard5 = seriesShortCourseDiscard5Check?.checked || false;
            let races = parseInt(numberOfRaces?.value);
            let discardThreshold = parseInt(racesPerDiscardInput?.value);
            const editId = editSeriesId?.value;
            const dncRuleInput = document.querySelector('input[name="dnc-scoring-rule"]:checked');
            const dncScoringRule = dncRuleInput ? dncRuleInput.value : 'raceEntries'; 
            if (!name) { alert('Series Name required.'); return; }
            if (isShortCourse) {
                discardThreshold = 0; 
            } else {
                if (isNaN(races) || isNaN(discardThreshold)) { alert('Number of Races and Races Per Discard required for standard series.'); return; }
                if (races < 1 || races > 50) { alert('Number of races must be 1-50.'); return; }
                if (discardThreshold < 0 || discardThreshold > 20 ) { alert(`'Races Per Discard' must be between 0 and 20. (0 means no discards).`); return; }
            }

            if (editId) {
                const seriesIndex = series.findIndex(s => s.id === parseInt(editId));
                if (seriesIndex !== -1) {
                    const existingSeries = series[seriesIndex];
                    existingSeries.name = name;
                    existingSeries.isShortCourse = isShortCourse;
                    existingSeries.shortCourseSingleDiscardAfter5Races = isShortCourse ? shortCourseDiscard5 : false;
                    existingSeries.dncScoringRule = isShortCourse ? 'raceEntries' : dncScoringRule; 
                    existingSeries.discardThreshold = isShortCourse ? 0 : discardThreshold;


                    if (isShortCourse) {
                         existingSeries.numberOfRaces = existingSeries.races.length;
                    } else {
                        const oldNumberOfRaces = existingSeries.numberOfRaces;
                        existingSeries.numberOfRaces = races;
                         if (races > oldNumberOfRaces) {
                            for (let i = oldNumberOfRaces + 1; i <= races; i++) {
                                existingSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] });
                            }
                        } else if (races < oldNumberOfRaces) {
                             const racesToRemove = existingSeries.races.slice(races);
                             const hasResultsInRemoved = racesToRemove.some(r => r.results && r.results.length > 0);
                             if (hasResultsInRemoved && !confirm(`Reducing races will remove races from Race ${races + 1} onwards, including any saved results for them. Continue?`)) {
                                 if (numberOfRaces) numberOfRaces.value = oldNumberOfRaces;
                                 existingSeries.numberOfRaces = oldNumberOfRaces;
                                 return;
                             }
                             existingSeries.races = existingSeries.races.slice(0, races);
                         }
                         existingSeries.races.sort((a,b) => a.raceNumber - b.raceNumber);
                    }
                    alert(`Series "${name}" updated.`);
                } else {
                     alert("Error finding series to update."); return;
                }
            } else {
                 const newSeries = {
                     id: Date.now(), name, isShortCourse,
                     numberOfRaces: isShortCourse ? 0 : races,
                     discardThreshold: isShortCourse ? 0 : discardThreshold,
                     shortCourseSingleDiscardAfter5Races: isShortCourse ? shortCourseDiscard5 : false,
                     dncScoringRule: isShortCourse ? 'raceEntries' : dncScoringRule, 
                     races: []
                 };
                 if (!isShortCourse) {
                     for (let i = 1; i <= races; i++) {
                         newSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] });
                     }
                 }
                 series.push(newSeries);
                 alert(`Series "${name}" (${isShortCourse ? 'Short Course' : 'Standard'}) created.`);
            }
            await saveDataToGoogleSheet();
            refreshSeriesList();
            refreshSeriesDropdowns();
            if(createSeriesForm) createSeriesForm.classList.add('hidden');
        });

        if(cancelSeriesBtn) cancelSeriesBtn.addEventListener('click', () => { if(createSeriesForm) createSeriesForm.classList.add('hidden'); });

        function refreshSeriesList() {
            if (!seriesList) return;
            seriesList.innerHTML = '';
            if (series.length === 0) {
                seriesList.innerHTML = '<p>No series defined. Create one first.</p>';
                return;
            }
            series.forEach(s => {
                const seriesCard = document.createElement('div');
                seriesCard.classList.add('race-card'); 
                
                const racesWithResults = s.races.filter(race => race.results && race.results.length > 0).length;
                let dncRuleText = '';
                const rule = s.dncScoringRule || 'raceEntries';
                if (rule === 'raceEntries') dncRuleText = 'Race Entries + 1';
                else dncRuleText = 'Series Competitors + 1';
                
                const seriesType = s.isShortCourse ? 'Short Course' : 'Standard';
                let discardTextToDisplay = '';

                let detailsArr = [];
                detailsArr.push(`<strong>Type:</strong> ${seriesType}`);

                if (s.isShortCourse) {
                    if (s.shortCourseSingleDiscardAfter5Races) {
                        discardTextToDisplay = '1 discard if &ge; 5 races completed';
                    } else {
                        discardTextToDisplay = 'No discards (SC default)';
                    }
                    detailsArr.push(`<strong>Races Saved:</strong> ${s.races.length}`); 
                    detailsArr.push(`<strong>Discard Rule:</strong> ${discardTextToDisplay}`);
                } else {
                    const discardThreshold = s.discardThreshold ?? 0;
                    discardTextToDisplay = discardThreshold > 0 ? `1 per ${discardThreshold} completed` : 'No discards';
                    detailsArr.push(`<strong>Races:</strong> ${s.numberOfRaces} planned (${racesWithResults} done)`);
                    detailsArr.push(`<strong>Discards:</strong> ${discardTextToDisplay}`);
                    detailsArr.push(`<strong>DNC Rule:</strong> ${dncRuleText}`);
                }
                
                seriesCard.innerHTML = `
                    <div class="race-info"><h3>${s.name}</h3></div>
                    <p class="series-card-details">${detailsArr.join(' | ')}</p>
                    <div class="race-actions">
                        <button class="btn-edit" onclick="editSeries(${s.id})">Edit</button>
                        <button class="btn-danger" onclick="deleteSeries(${s.id})">Del</button>
                    </div>`;
                seriesList.appendChild(seriesCard);
            });
        }

        function editSeries(id) {
            const s = series.find(s => s.id === id); if (!s) return;
            if(seriesName) seriesName.value = s.name;
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = s.isShortCourse || false;
            
            if (seriesShortCourseCheck) seriesShortCourseCheck.dispatchEvent(new Event('change')); 

            if (s.isShortCourse) {
                 if(seriesShortCourseDiscard5Check) seriesShortCourseDiscard5Check.checked = s.shortCourseSingleDiscardAfter5Races || false;
                 if(numberOfRaces) numberOfRaces.value = s.races.length > 0 ? s.races.length : '1'; 
                 if(racesPerDiscardInput) racesPerDiscardInput.value = '0'; 
            } else {
                 if(numberOfRaces) numberOfRaces.value = s.numberOfRaces;
                 if(racesPerDiscardInput) racesPerDiscardInput.value = s.discardThreshold ?? 0;
                 if(seriesShortCourseDiscard5Check) seriesShortCourseDiscard5Check.checked = false; 
            }
            if(editSeriesId) editSeriesId.value = s.id;
            const currentDncRule = s.dncScoringRule || 'raceEntries';
            const dncRadioToSelect = document.getElementById(`dnc-rule-${currentDncRule === 'seriesCompetitors' ? 'series' : 'race'}`);
            if (dncRadioToSelect) dncRadioToSelect.checked = true;
            else { const defaultDncRadio = document.getElementById('dnc-rule-race'); if(defaultDncRadio) defaultDncRadio.checked = true; }
            
            if(createSeriesForm) {
                createSeriesForm.classList.remove('hidden');
                createSeriesForm.scrollIntoView({ behavior: 'smooth' });
            }
        }

        async function deleteSeries(id) {
            const seriesIndex = series.findIndex(s => s.id === id); if (seriesIndex === -1) return; const s = series[seriesIndex];
            if (confirm(`DELETE Series "${s.name}" and ALL its data permanently? Cannot be undone.`)) {
                series.splice(seriesIndex, 1);
                await saveDataToGoogleSheet();
                refreshSeriesList(); refreshSeriesDropdowns();
                if (selectSeries?.value == id) selectSeries.value = "";
                if (viewSeries?.value == id) { viewSeries.value = ""; calculateSeriesResults(); }
                if (viewAllSeries?.value == id) { viewAllSeries.value = ""; displayRaceViewer();}
                if (currentSeries && currentSeries.id === id) {
                    currentSeries = null; currentRace = null; entries = []; results = []; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults(); 
                }
                alert(`Series "${s.name}" deleted.`);
            }
        }

        function refreshSeriesDropdowns() {
             const dropdowns = [selectSeries, viewSeries, viewAllSeries].filter(Boolean); 
             dropdowns.forEach((dropdown) => {
                 if (!dropdown) return; const selectedVal = dropdown.value; dropdown.innerHTML = '<option value="">Select Series</option>';
                 series.sort((a, b) => a.name.localeCompare(b.name));
                 series.forEach(s => { const option = document.createElement('option'); option.value = s.id; option.textContent = s.name + (s.isShortCourse ? ' (Short Course)' : ''); dropdown.appendChild(option); });
                 if (selectedVal && series.some(s => s.id == selectedVal)) dropdown.value = selectedVal; else dropdown.value = "";
             });
             setTimeout(() => { 
                if (raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
             }, 0);
         }

         function updateRaceEntryUI() {
             const seriesId = selectSeries?.value;
             if (!seriesId) {
                 currentSeries = null; currentRace = null;
                 switchToStandardRaceUI(); 
                 if(selectRace) selectRace.innerHTML = '<option value="">-- Select Race --</option>';
                 entries = [];
                 renderEntriesTable(); clearEntryForm(); clearShortCourseSessionData();
                 return;
             }
             currentSeries = series.find(s => s.id === parseInt(seriesId));
             if (!currentSeries) {
                 console.error("Selected series not found!");
                 currentSeries = null; currentRace = null;
                 switchToStandardRaceUI();
                 if(selectRace) selectRace.innerHTML = '<option value="">-- Select Race --</option>';
                 entries = [];
                 renderEntriesTable(); clearEntryForm(); clearShortCourseSessionData();
                 return;
             }
             entries = []; 
             clearShortCourseSessionData(); 
             editMode = false; editModeWarning?.classList.add('hidden');
             clearEntryForm(); 

             if (currentSeries.isShortCourse) {
                 switchToShortCourseUI();
                 renderShortCoursePoolTable();
             } else {
                 switchToStandardRaceUI();
                 updateRaceDropdown(); 
             }
         }

         function switchToStandardRaceUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.remove('hidden');
             if (standardEntryFields) standardEntryFields.classList.remove('hidden');
             if (mainFormStatusGroup) mainFormStatusGroup.classList.add('hidden'); 
             if (timeInputs) timeInputs.classList.add('hidden'); 

             if (standardEntriesDisplay) standardEntriesDisplay.classList.remove('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.add('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.add('hidden');
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.add('hidden');
             if (removeLastShortCourseRaceBtn) removeLastShortCourseRaceBtn.classList.add('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add/Edit Boat Entry";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Race";
             if (clearAllBtn) clearAllBtn.textContent = "Clear All Current Entries";
         }

         function switchToShortCourseUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.add('hidden');
             if (standardEntryFields) standardEntryFields.classList.add('hidden'); 
             if(mainFormStatusGroup) mainFormStatusGroup.classList.add('hidden'); 
             if(timeInputs) timeInputs.classList.add('hidden'); 

             if (standardEntriesDisplay) standardEntriesDisplay.classList.add('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.remove('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.remove('hidden');
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.remove('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add Boat to Entries";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Entries";
             if (clearAllBtn) clearAllBtn.textContent = "Clear Current Entries";
             if (selectRace) selectRace.innerHTML = ''; 
             currentRace = null;
             renderShortCourseSessionRaces(); 
             updateCreateRaceButton();
             updateRemoveLastRaceButtonVisibility();
         }

        function updateRaceDropdown() { 
            if (!selectRace || !currentSeries || currentSeries.isShortCourse) {
                 if (selectRace) selectRace.innerHTML = '';
                 updateRaceInfoAndEntries(); 
                 return;
            }
            const oldRaceVal = selectRace.value;
            populateRaceOptions(selectRace, currentSeries, true, true); 
            
            if (oldRaceVal && Array.from(selectRace.options).some(opt => opt.value === oldRaceVal)) {
                selectRace.value = oldRaceVal;
            } else {
                selectRace.value = ""; 
            }
            updateRaceInfoAndEntries(); 
        }

        function populateRaceOptions(dropdown, seriesData, showDetails, addPlaceholder = false) {
            if (!dropdown || !seriesData) return;
            dropdown.innerHTML = '';

            if (addPlaceholder) {
                const placeholderOption = document.createElement('option');
                placeholderOption.value = "";
                placeholderOption.textContent = "-- Select Race --";
                dropdown.appendChild(placeholderOption);
            }

            const hasPotentialRaces = seriesData.isShortCourse ?
                                     (seriesData.races && seriesData.races.length > 0) :
                                     (typeof seriesData.numberOfRaces === 'number' && seriesData.numberOfRaces > 0);

            if (!hasPotentialRaces && seriesData.races.length === 0) { 
                if (!addPlaceholder) { 
                    dropdown.innerHTML = '<option value="">No races</option>';
                }
                dropdown.disabled = true;
                return;
            }
            dropdown.disabled = false; 

            const sortedRacesFromData = seriesData.races ? [...seriesData.races].sort((a,b) => a.raceNumber - b.raceNumber) : [];
            let raceNumbersToDisplay = [];

            if (seriesData.isShortCourse) {
                raceNumbersToDisplay = sortedRacesFromData.map(r => r.raceNumber);
            } else { 
                for (let i = 1; i <= seriesData.numberOfRaces; i++) {
                    raceNumbersToDisplay.push(i);
                }
            }
            
            if (raceNumbersToDisplay.length === 0 && !addPlaceholder) {
                 dropdown.innerHTML = '<option value="">No races defined</option>';
                 dropdown.disabled = true;
                 return;
            }


            raceNumbersToDisplay.forEach(raceNumValue => {
                const race = sortedRacesFromData.find(r => r.raceNumber === raceNumValue); 
                const option = document.createElement('option');
                option.value = raceNumValue;
                let text = `Race ${raceNumValue}`;

                if (showDetails) {
                    if (race && race.results && race.results.length > 0) {
                        text += ` (Saved)`;
                    } else if (!seriesData.isShortCourse) { 
                         text += ` (Not Saved)`;
                    } else if (seriesData.isShortCourse && race) { 
                        text += ` (No Results)`;
                    }
                }
                option.textContent = text;
                dropdown.appendChild(option);
            });
             if (dropdown.options.length === (addPlaceholder ? 1:0) ) { 
                  if(!addPlaceholder) dropdown.innerHTML = '<option value="">No races</option>';
                  dropdown.disabled = true;
             }
        }


        function updateRaceInfoAndEntries() { 
             if (!currentSeries || currentSeries.isShortCourse) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden');
                 currentRace = null;
                 return;
             }
             const selectedRaceNum = selectRace?.value;
             if (!selectedRaceNum) { 
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null;
                 return;
             }
             currentRace = parseInt(selectedRaceNum);
             if (isNaN(currentRace)) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null;
                 return;
             }
             const race = currentSeries.races.find(r => r.raceNumber === currentRace);
             if (!race) { 
                 console.warn(`Race data for race ${currentRace} not found in series ${currentSeries.name}`);
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm(); return;
              }
             const hasSavedEntries = race.entries && race.entries.length > 0;
             const hasSavedResults = race.results && race.results.length > 0;

             if (hasSavedEntries || hasSavedResults) { 
                 if (editMode && entries.length > 0) { 
                     if (!confirm(`You have unsaved entries/changes. Load saved data for Race ${currentRace}? (Discards current changes)`)) {
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         return;
                     }
                 }
                 if (hasSavedEntries) {
                     entries = JSON.parse(JSON.stringify(race.entries));
                 } else { 
                     entries = race.results.map(res => ({
                         savedBoatId: res.savedBoatId,
                         sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper,
                         yardstick: res.yardstick,
                         status: res.status, elapsedTime: res.elapsedTime || ''
                     }));
                 }
                 renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden');
             } else { 
                 if (editMode && entries.length > 0) { 
                     if (!confirm(`You have unsaved entries/changes. Clear list for Race ${currentRace}? (Discards current changes)`)) {
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         return;
                     }
                 }
                 entries = []; 
                 renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden');
             }
        }

        if(selectSeries) selectSeries.addEventListener('change', updateRaceEntryUI);
        if(selectRace) selectRace.addEventListener('change', () => {
             if (currentSeries && !currentSeries.isShortCourse) {
                 updateRaceInfoAndEntries();
             }
        });
        
        if(viewSeries) viewSeries.addEventListener('change', calculateSeriesResults);
        if(viewAllSeries) viewAllSeries.addEventListener('change', displayRaceViewer);


        function loadRaceResults() {
            if (!currentSeries || typeof currentRace !== 'number') {
                 results = []; 
                 renderRaceResults(); 
                 return;
            }
            const race = currentSeries.races.find(r => r.raceNumber === currentRace);
            if (!race || !race.results || race.results.length === 0) {
                results = []; 
            } else {
                results = JSON.parse(JSON.stringify(race.results)); 
            }
            renderRaceResults(); 
        }


        function calculateSeriesResults() {
            const seriesId = viewSeries?.value;
            if (seriesResultsBody) seriesResultsBody.innerHTML = ''; if (seriesResultsHeader) seriesResultsHeader.innerHTML = '<tr><th>Loading...</th></tr>'; if (legendDiv) legendDiv.innerHTML = '<strong>Legend:</strong>';
            if (!seriesId) { if(seriesSummary) seriesSummary.innerHTML = '<p>Select a series.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId));
            if (!selectedSeries) { if(seriesSummary) seriesSummary.innerHTML = '<p>Error: Series not found.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }

             const racesWithResults = selectedSeries.races.filter(r => r.results && r.results.length > 0);
             const completedRacesCount = racesWithResults.length;
             const totalRacesInSeries = selectedSeries.races.length; 
             
             let numDiscardsToApply = 0;
             let discardRuleText = 'None';

             if (selectedSeries.isShortCourse) {
                if (selectedSeries.shortCourseSingleDiscardAfter5Races && completedRacesCount >= 5) {
                    numDiscardsToApply = 1;
                    discardRuleText = '1 discard (>=5 races completed)';
                } else if (selectedSeries.shortCourseSingleDiscardAfter5Races) {
                    discardRuleText = '1 discard if >= 5 races (0 applied)';
                } else {
                    discardRuleText = 'No discards (Short Course default)';
                }
             } else { 
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 if (discardThreshold > 0 && completedRacesCount > 0) {
                     numDiscardsToApply = Math.floor(completedRacesCount / discardThreshold);
                 }
                 discardRuleText = discardThreshold > 0 ? `1 per ${discardThreshold} completed races` : 'No discards';
             }


            if (completedRacesCount === 0) {
                let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
                if (selectedSeries.isShortCourse) {
                     summaryHTML += `<p><strong>Races Saved:</strong> ${totalRacesInSeries}</p>`;
                } else {
                    summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>`;
                }
                 summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p><p style="color: orange; font-weight: bold;">No results saved yet.</p></div>`;
                 if(seriesSummary) seriesSummary.innerHTML = summaryHTML;
                 if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No race results available.</td></tr>'; return;
             }
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${completedRacesCount}</p>`;
             } else {
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRacesCount}</p>`;
             }
             summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             if (numDiscardsToApply > 0) { 
                 summaryHTML += `<p><strong>Discards Applied Now:</strong> ${numDiscardsToApply}</p>`;
             }
              summaryHTML += `</div>`;
              if(seriesSummary) seriesSummary.innerHTML = summaryHTML;

             const raceNumbersInSeries = selectedSeries.races.map(r => r.raceNumber).sort((a, b) => a - b);
             if (raceNumbersInSeries.length === 0) {
                  if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No races found.</td></tr>'; return;
             }
             let headerHTML = `<tr><th>Pos</th><th>Sail #</th><th>Skipper</th><th>Boat Class</th>`;
             raceNumbersInSeries.forEach(num => headerHTML += `<th>R${num}</th>`);
             headerHTML += `<th>Total</th><th>Net</th></tr>`;
             if(seriesResultsHeader) seriesResultsHeader.innerHTML = headerHTML;

             const competitors = new Map(); let allSailNumbers = new Set(); selectedSeries.races.forEach(r => { if(r.results) r.results.forEach(res => allSailNumbers.add(res.sailNumber)); });
             allSailNumbers.forEach(sailNo => {
                 if (!competitors.has(sailNo)) { let lastResult = null; for (let i = selectedSeries.races.length - 1; i >= 0; i--) { const r = selectedSeries.races[i]; if (r.results) { lastResult = r.results.find(res => res.sailNumber === sailNo); if (lastResult) break; } } competitors.set(sailNo, { sailNumber: sailNo, skipper: lastResult?.skipper || 'N/A', boatClass: lastResult?.boatClass || 'N/A', raceScores: new Map(), totalPoints: 0, netPoints: 0, position: 0 }); }
             });
             selectedSeries.races.forEach(race => { const raceNum = race.raceNumber; if (race.results && race.results.length > 0) { race.results.forEach(result => { const competitor = competitors.get(result.sailNumber); if(competitor) competitor.raceScores.set(raceNum, { points: result.points, status: result.status.toUpperCase(), position: result.position, discarded: false }); }); } });

             competitors.forEach(competitor => {
                  competitor.raceScores.forEach(score => { if (score) score.discarded = false; });
                  const dncRule = selectedSeries.dncScoringRule || 'raceEntries';
                  const totalSeriesCompetitors = competitors.size;
                  raceNumbersInSeries.forEach(raceNum => {
                      if (!competitor.raceScores.has(raceNum)) {
                          const correspondingRace = selectedSeries.races.find(r => r.raceNumber === raceNum);
                          if (correspondingRace && correspondingRace.results && correspondingRace.results.length > 0) {
                              let dncPoints;
                              if (dncRule === 'raceEntries') { const numEntriesInRace = correspondingRace.results.length; dncPoints = numEntriesInRace + 1; }
                              else { dncPoints = totalSeriesCompetitors + 1; }
                              competitor.raceScores.set(raceNum, { points: dncPoints, status: 'DNC', position: 'DNC', discarded: false });
                          } else {
                              competitor.raceScores.set(raceNum, { points: null, status: 'NR', position: 'NR', discarded: false });
                          }
                      } else {
                          const score = competitor.raceScores.get(raceNum);
                          if (score.status === 'OOD') {
                              score.points = calculateOODPointsSeriesContext(competitor.sailNumber, raceNum, selectedSeries, competitors);
                              competitor.raceScores.set(raceNum, score);
                          }
                      }
                  });
                  const validScores = Array.from(competitor.raceScores.values()).filter(score => score && score.points !== null && !isNaN(score.points));
                  competitor.totalPoints = validScores.reduce((sum, score) => sum + score.points, 0);

                  if (validScores.length > 0 && numDiscardsToApply > 0) {
                      const scoresEligibleForDiscard = Array.from(competitor.raceScores.entries())
                          .filter(([rn, score]) => score && score.points !== null && !isNaN(score.points))
                          .map(([rn, score]) => ({ ...score, raceNumber: rn }))
                          .sort((a, b) => b.points - a.points);

                      for(let i = 0; i < Math.min(numDiscardsToApply, scoresEligibleForDiscard.length); i++){
                          const raceNumToDiscard = scoresEligibleForDiscard[i].raceNumber;
                          const scoreToDiscard = competitor.raceScores.get(raceNumToDiscard);
                          if (scoreToDiscard) scoreToDiscard.discarded = true;
                      }
                  }
                   competitor.netPoints = Array.from(competitor.raceScores.values())
                                             .reduce((sum, score) => {
                                                 if (score && score.points !== null && !isNaN(score.points) && !score.discarded) return sum + score.points;
                                                 return sum;
                                             }, 0);
              });

             const competitorsArray = Array.from(competitors.values());
             competitorsArray.sort((a, b) => {
                 if (a.netPoints !== b.netPoints) return a.netPoints - b.netPoints;
                 let lastCommonRaceResult = 0;
                 const sortedRaceNumbersDesc = [...raceNumbersInSeries].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) {
                      const scoreA = a.raceScores.get(raceNum);
                      const scoreB = b.raceScores.get(raceNum);
                      const pointsA = (scoreA && !scoreA.discarded && scoreA.points != null && !isNaN(scoreA.points)) ? scoreA.points : null;
                      const pointsB = (scoreB && !scoreB.discarded && scoreB.points != null && !isNaN(scoreB.points)) ? scoreB.points : null;

                      if (pointsA !== null && pointsB !== null) {
                          if (pointsA !== pointsB) { lastCommonRaceResult = pointsA - pointsB; break; }
                      } else if (pointsA !== null) { return -1;
                      } else if (pointsB !== null) { return 1;
                      }
                 }
                 if (lastCommonRaceResult !== 0) return lastCommonRaceResult;

                 const scoresA_nonDiscarded = Array.from(a.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB_nonDiscarded = Array.from(b.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA_nonDiscarded.length, scoresB_nonDiscarded.length); i++) {
                     if (scoresA_nonDiscarded[i] !== scoresB_nonDiscarded[i]) return scoresA_nonDiscarded[i] - scoresB_nonDiscarded[i];
                 }
                 if (numDiscardsToApply > 0) {
                    const discardedA_scores = Array.from(a.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB_scores = Array.from(b.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                     if (discardedA_scores.length > 0 && discardedB_scores.length > 0 && discardedA_scores[0] !== discardedB_scores[0]) {
                         return discardedA_scores[0] - discardedB_scores[0];
                     }
                 }
                 return a.sailNumber.localeCompare(b.sailNumber, undefined, { numeric: true });
             });

             let currentRank = 0; let currentPosition = 0;
             for (let i = 0; i < competitorsArray.length; i++) {
                 currentRank++;
                 if (i === 0 || checkTieBrokenSeries(competitorsArray[i], competitorsArray[i-1], raceNumbersInSeries, numDiscardsToApply > 0)) {
                     currentPosition = currentRank;
                 }
                 competitorsArray[i].position = currentPosition;
             }
             function checkTieBrokenSeries(boatA, boatB, raceNums, discardsWereAppliedForNet) {
                 if (boatA.netPoints !== boatB.netPoints) return true;

                 const sortedRaceNumbersDesc = [...raceNums].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) {
                     const scoreA = boatA.raceScores.get(raceNum);
                     const scoreB = boatB.raceScores.get(raceNum);
                     const pointsA = (scoreA && !scoreA.discarded && scoreA.points != null && !isNaN(scoreA.points)) ? scoreA.points : null;
                     const pointsB = (scoreB && !scoreB.discarded && scoreB.points != null && !isNaN(scoreB.points)) ? scoreB.points : null;
                     if (pointsA !== null && pointsB !== null) { if(pointsA !== pointsB) return true; }
                     else if (pointsA !== null) return true;
                     else if (pointsB !== null) return true;
                 }
                 const scoresA_nd = Array.from(boatA.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB_nd = Array.from(boatB.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA_nd.length, scoresB_nd.length); i++) { if (scoresA_nd[i] !== scoresB_nd[i]) return true; }
                 if (scoresA_nd.length !== scoresB_nd.length) return true;
                 
                 if (discardsWereAppliedForNet) { 
                    const discardedA_s = Array.from(boatA.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB_s = Array.from(boatB.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    if (discardedA_s.length > 0 && discardedB_s.length > 0 && discardedA_s[0] !== discardedB_s[0]) return true;
                 }
                 if (boatA.sailNumber.localeCompare(boatB.sailNumber, undefined, { numeric: true }) !== 0) return true;
                 return false;
              }

            if(seriesResultsBody) {
                 seriesResultsBody.innerHTML = ''; if (competitorsArray.length === 0) { const row = seriesResultsBody.insertRow(); row.insertCell().textContent = 'No competitors found with results in this series.'; row.cells[0].colSpan = raceNumbersInSeries.length + 6; return; }
                 competitorsArray.forEach(competitor => {
                     const row = seriesResultsBody.insertRow();
                     let rowHTML = `<td>${competitor.position}</td><td>${competitor.sailNumber}</td><td>${competitor.skipper}</td><td>${competitor.boatClass}</td>`;
                     raceNumbersInSeries.forEach(raceNum => {
                         const score = competitor.raceScores.get(raceNum);
                         if (!score || score.status === 'NR') { rowHTML += `<td class="nr-cell" title="No Race / Not Sailed">NR</td>`; }
                         else {
                             const points = (score.points !== null && !isNaN(score.points)) ? score.points : '-'; const status = score.status.toUpperCase(); let cellContent = points;
                             if (status !== 'FINISHED') cellContent = `${points}(${status})`;
                             const title = `title="${status} (Race Pos: ${score.position ?? status})"`;
                             rowHTML += `<td class="${score.discarded ? 'discarded' : ''}" ${title}>${cellContent}</td>`;
                         }
                     });
                     rowHTML += `<td>${competitor.totalPoints}</td><td><strong>${competitor.netPoints}</strong></td>`; row.innerHTML = rowHTML;
                 });
                 if (legendDiv) { legendDiv.innerHTML = `<strong>Legend:</strong> <span class="discarded-example">15</span> Discarded Score,&nbsp; <span class="nr-cell">NR</span> No Race/Not Sailed,&nbsp; <span>DNF</span> Did Not Finish,&nbsp; <span>DNS</span> Did Not Start,&nbsp; <span>OCS</span> On Course Side,&nbsp; <span>DSQ</span> Disqualified,&nbsp; <span>OOD</span> Race Officer Duty,&nbsp; <span>DNC</span> Did Not Compete (Race Sailed)`; }
             }
        }

        function calculateOODPointsSeriesContext(sailNo, oodRaceNumber, seriesData, competitorMap) {
             const oodRaceData = seriesData.races.find(r => r.raceNumber === oodRaceNumber);
             let oodPointsForThisRace = 0; 
             let finisherPointsInOODRace = [];

             if (oodRaceData && oodRaceData.results) {
                  oodRaceData.results.forEach(result => {
                      if (result.sailNumber !== sailNo && result.status === 'finished') {
                           if (result.points != null && !isNaN(result.points)) {
                               finisherPointsInOODRace.push(result.points);
                           }
                      }
                  });
             }

             if (finisherPointsInOODRace.length > 0) {
                 const avgFinisherPoints = finisherPointsInOODRace.reduce((sum, r) => sum + r, 0) / finisherPointsInOODRace.length;
                 oodPointsForThisRace = Math.round(avgFinisherPoints * 10) / 10;
             } else {
                 oodPointsForThisRace = 0;
             }
             return oodPointsForThisRace;
         }


        function displayRaceViewer() {
            const seriesId = viewAllSeries?.value;
            if (raceSelector) raceSelector.innerHTML = ''; if (individualRaceInfo) individualRaceInfo.innerHTML = ''; if (individualRaceBody) individualRaceBody.innerHTML = ''; if (raceSummaryView) raceSummaryView.innerHTML = '';
            if (!seriesId) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Select a series.</p>'; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId)); if (!selectedSeries) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Error: Series not found.</p>'; return; }
            const completedRaces = selectedSeries.races.filter(r => r.results && r.results.length > 0).length;
            const totalRacesSaved = selectedSeries.races.length;
            const seriesType = selectedSeries.isShortCourse ? 'Short Course' : 'Standard';
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${seriesType})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${totalRacesSaved}</p>`;
             } else {
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 const discardRuleText = discardThreshold > 0 ? `1 discard per ${discardThreshold} completed races` : 'No discards';
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRaces}</p>
                                <p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             }
             summaryHTML += `</div>`;
             if(raceSummaryView) raceSummaryView.innerHTML = summaryHTML;
             const raceNumbersToShow = selectedSeries.races.map(r => r.raceNumber).sort((a,b) => a - b);
             if (raceNumbersToShow.length === 0) {
                 if (raceSelector) raceSelector.innerHTML = '<p>No races saved in this series yet.</p>';
                 return;
             }
            let firstRaceWithResults = -1;
            if (raceSelector) {
                 raceNumbersToShow.forEach(raceNum => {
                    const raceBtn = document.createElement('button'); raceBtn.textContent = `Race ${raceNum}`; raceBtn.classList.add('race-button'); raceBtn.dataset.raceNumber = raceNum;
                    const race = selectedSeries.races.find(r => r.raceNumber === raceNum); const hasResults = race && race.results && race.results.length > 0;
                    if (hasResults) {
                        raceBtn.classList.add('has-results');
                        if (firstRaceWithResults === -1) firstRaceWithResults = raceNum;
                    }
                    raceBtn.addEventListener('click', (e) => { document.querySelectorAll('.race-button.active').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); displayRaceResultsView(selectedSeries, raceNum); });
                    raceSelector.appendChild(raceBtn);
                 });
            }
            let lastRaceWithResults = -1;
            const sortedRacesDesc = [...selectedSeries.races].sort((a,b) => b.raceNumber - a.raceNumber);
             for(const race of sortedRacesDesc){
                 if(race && race.results && race.results.length > 0){
                     lastRaceWithResults = race.raceNumber;
                     break;
                 }
             }
             const targetRaceNum = lastRaceWithResults !== -1 ? lastRaceWithResults : (raceNumbersToShow.length > 0 ? raceNumbersToShow[0] : null);

            if (targetRaceNum !== null) {
                const targetButton = raceSelector?.querySelector(`.race-button[data-race-number="${targetRaceNum}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                    displayRaceResultsView(selectedSeries, targetRaceNum);
                }
            } else {
                if(individualRaceInfo) individualRaceInfo.innerHTML = '<p>Select a race button above.</p>';
            }
        }

        function displayRaceResultsView(selectedSeriesData, raceNumber) {
             if (!individualRaceBody || !individualRaceInfo || !selectedSeriesData) return; individualRaceBody.innerHTML = ''; individualRaceInfo.innerHTML = '';
             const race = selectedSeriesData.races.find(r => r.raceNumber === parseInt(raceNumber));
             if (!race || !race.results || race.results.length === 0) { individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${raceNumber} Results</h3><p>No results saved for this race.</p></div>`; const row = individualRaceBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 9; cell.textContent = 'No results saved for this race.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return; }
             individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${race.raceNumber} Results</h3><p><strong>Entries:</strong> ${race.results.length}</p></div>`;
             const sortedResults = [...race.results].sort((a, b) => { const posA = (typeof a.position === 'number') ? a.position : Infinity; const posB = (typeof b.position === 'number') ? b.position : Infinity; if(posA !== posB) return posA - posB; const pointsA = (a.points != null) ? a.points : Infinity; const pointsB = (b.points != null) ? b.points : Infinity; if (pointsA !== pointsB) return pointsA - pointsB; return a.sailNumber.localeCompare(b.sailNumber); });
             sortedResults.forEach(result => {
                 const row = individualRaceBody.insertRow();
                 row.innerHTML = `
                     <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                     <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                     <td>${result.points ?? '-'}</td>`;
             });
         }

        async function saveDataToGoogleSheet() {
            if (!WEB_APP_URL) {
                console.error("WEB_APP_URL is not defined. Cannot save to Google Sheet.");
                alert("Configuration error: Web App URL not set. Data not saved to cloud.");
                return;
            }
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            console.log("Saving to Google Sheet...");

            const dataToSave = {
                seriesData: series,
                boatListData: boatList
            };

            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSave),
                    redirect: 'follow'
                });

                const resultText = await response.text();
                let result;
                try {
                    result = JSON.parse(resultText);
                } catch (e) {
                    console.error("Failed to parse response from Google Sheet save:", resultText);
                    throw new Error("Invalid response from server: " + resultText.substring(0,100) + "...");
                }

                if (result.status === "success") {
                    console.log("Data successfully saved to Google Sheet:", result.message);
                } else {
                    console.error("Error saving to Google Sheet:", result.message);
                    alert("Error saving to Google Sheet: " + result.message + "\nPlease check the script logs if you are the owner.");
                }
            } catch (error) {
                console.error("Fetch error while saving to Google Sheet:", error);
                alert("Failed to connect to Google Sheet to save data. Error: " + error.message);
            } finally {
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
            }
        }

        async function loadDataFromGoogleSheet() {
            if (!WEB_APP_URL) {
                console.error("WEB_APP_URL is not defined. Cannot load from Google Sheet.");
                series = []; boatList = []; return;
            }
             if (loadingOverlay) { loadingOverlay.textContent = "Loading from Cloud..."; loadingOverlay.classList.remove('hidden'); }
            console.log("Loading from Google Sheet...");

            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'GET', mode: 'cors', cache: 'no-cache', redirect: 'follow'
                });
                const resultText = await response.text();
                let data;
                try {
                    data = JSON.parse(resultText);
                } catch (e) {
                    console.error("Failed to parse response from Google Sheet load:", resultText);
                    throw new Error("Invalid response from server: " + resultText.substring(0,100) + "...");
                }

                if (data.status === "success") {
                    console.log("Data successfully loaded from Google Sheet.");
                    if (data.seriesData && Array.isArray(data.seriesData)) {
                        series = data.seriesData.map((s, index) => {
                            if (!s || typeof s !== 'object') { console.warn(`GS Load: Invalid series data at index ${index}, skipping.`); return null; }
                            s.id = s.id || (Date.now() + index);
                            s.name = s.name || `Series ${s.id}`;
                            s.races = (Array.isArray(s.races) ? s.races : []).map((r, r_idx) => {
                                if (!r || typeof r !== 'object') return { raceNumber: r_idx + 1, date: null, entries: [], results: [] };
                                r.raceNumber = typeof r.raceNumber === 'number' ? r.raceNumber : r_idx + 1;
                                
                                const standardizeTimesInArray = (arr) => {
                                    return (Array.isArray(arr) ? arr : []).map(item => {
                                        const boatFromList = boatList.find(b => b.id === item.savedBoatId);
                                        let standardizedElapsedTime = item.elapsedTime || '';
                                        if (item.status === 'finished' && standardizedElapsedTime) {
                                            const seconds = timeToSeconds(standardizedElapsedTime);
                                            if (seconds >= 0) standardizedElapsedTime = secondsToTime(seconds);
                                        }
                                        return {...item, elapsedTime: standardizedElapsedTime, savedBoatId: item.savedBoatId || null, yardstick: item.yardstick || boatFromList?.yardstick || 100 };
                                    });
                                };
                                r.entries = standardizeTimesInArray(r.entries);
                                r.results = standardizeTimesInArray(r.results);
                                r.date = r.date || null;
                                return r;
                            });
                            s.isShortCourse = typeof s.isShortCourse === 'boolean' ? s.isShortCourse : false;
                            s.shortCourseSingleDiscardAfter5Races = typeof s.shortCourseSingleDiscardAfter5Races === 'boolean' ? s.shortCourseSingleDiscardAfter5Races : false;
                            s.numberOfRaces = typeof s.numberOfRaces === 'number' ? s.numberOfRaces : (s.isShortCourse ? s.races.length : 0);
                            s.discardThreshold = typeof s.discardThreshold === 'number' ? s.discardThreshold : 0;
                            s.dncScoringRule = ['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule) ? s.dncScoringRule : 'raceEntries';

                            if (!s.isShortCourse) {
                                const expectedNumRaces = s.numberOfRaces || 0;
                                if (s.races.length !== expectedNumRaces) {
                                   console.warn(`GS Load: Fixing race structure for standard series "${s.name}". Expected ${expectedNumRaces}, found ${s.races.length}.`);
                                   let existingRacesData = new Map();
                                   s.races.forEach(r_item => { if (r_item && typeof r_item.raceNumber === 'number') existingRacesData.set(r_item.raceNumber, r_item); });
                                   let reconciledRaces = [];
                                   for (let i_race = 1; i_race <= expectedNumRaces; i_race++) {
                                       const existing = existingRacesData.get(i_race);
                                       const defaultYardstick = existing?.savedBoatId ? (boatList.find(b=>b.id === existing.savedBoatId)?.yardstick || 100) : 100;
                                       
                                       const mapEntries = (entriesArray) => (Array.isArray(entriesArray) ? entriesArray : []).map(entry => {
                                           let stdTime = entry.elapsedTime || '';
                                           if (entry.status === 'finished' && stdTime) { const secs = timeToSeconds(stdTime); if (secs >= 0) stdTime = secondsToTime(secs); }
                                           return {...entry, elapsedTime: stdTime, savedBoatId: entry.savedBoatId || null, yardstick: entry.yardstick || defaultYardstick};
                                       });

                                       reconciledRaces.push({
                                           raceNumber: i_race,
                                           date: existing?.date || null,
                                           entries: mapEntries(existing?.entries),
                                           results: mapEntries(existing?.results)
                                       });
                                   }
                                   s.races = reconciledRaces;
                                }
                            }
                            s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));
                            return s;
                        }).filter(s => s !== null);
                    } else {
                        series = [];
                        if(data.message && data.status !== "success") console.warn("Series data not found or error in response:", data.message);
                        else if (!data.seriesData) console.warn("Series data missing from successful GS response.");
                    }

                    if (data.boatListData && Array.isArray(data.boatListData)) {
                        const existingIds = new Set();
                        boatList = data.boatListData.map((b, index) => {
                            if (!b || typeof b !== 'object') return null;
                            let id = b.id || (Date.now() + index + Math.random());
                            if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_gs";
                            existingIds.add(id);
                            const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                            const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                            const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                            const yardstickVal = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                            if (!sailNumber || !boatClass || !skipper || yardstickVal <= 0) {
                                 console.warn(`GS Load: Imported boat missing data, assigning defaults/skipping: ID ${id}`); return null;
                            }
                            return { id, sailNumber, boatClass, skipper, yardstick: yardstickVal };
                        }).filter(b => b !== null);
                    } else {
                        boatList = [];
                        if(data.message && data.status !== "success") console.warn("BoatList data not found or error in response:", data.message);
                        else if (!data.boatListData) console.warn("BoatList data missing from successful GS response.");
                    }
                } else {
                    console.error("Error loading from Google Sheet:", data.message || "Unknown error from script.");
                    alert("Error loading data from Google Sheet: " + (data.message || "Unknown error") + "\nApp will start with empty data.");
                    series = []; boatList = [];
                }
            } catch (error) {
                console.error("Fetch error while loading from Google Sheet:", error);
                alert("Failed to connect to Google Sheet to load data. Error: " + error.message + "\nApp will start with empty data.");
                series = []; boatList = [];
            } finally {
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
            }
        }


        function exportAllData() {
            if (series.length === 0 && boatList.length === 0) { alert("No data (series or boats) available to export."); return; }
            try {
                const exportData = {
                    version: "LysterfieldResultsApp_vGS_1.3", 
                    exportDate: new Date().toISOString(),
                    seriesData: series,
                    boatListData: boatList
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `lysterfield_gs_backup_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Data exported to local JSON file successfully!");
            } catch (error) { console.error("Error during data export:", error); alert("An error occurred while exporting data."); }
        }
        function exportBoatList() {
            if (boatList.length === 0) { alert("No boats in the list to export."); return; }
            try {
                const jsonString = JSON.stringify(boatList, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `lysterfield_boatlist_backup_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Boat list exported to local JSON file successfully!");
            } catch (error) { console.error("Error during boat list export:", error); alert("An error occurred while exporting the boat list."); }
        }


        async function importData(event) {
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING DATA WILL REPLACE ALL CURRENT IN-APP DATA AND THEN SAVE IT TO GOOGLE SHEETS. Are you absolutely sure?")) { importFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result; const parsedData = JSON.parse(fileContent);
                    if (!parsedData || typeof parsedData !== 'object' || !Array.isArray(parsedData.seriesData) || !Array.isArray(parsedData.boatListData)) { throw new Error("Invalid file format. Expected object with 'seriesData' and 'boatListData' arrays."); }

                    if (parsedData.boatListData && Array.isArray(parsedData.boatListData)) {
                        const existingIds = new Set();
                        boatList = parsedData.boatListData.map((b, index) => {
                            if (!b || typeof b !== 'object') return null;
                            let id = b.id || (Date.now() + index + Math.random());
                            if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_json";
                            existingIds.add(id);
                            const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                            const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                            const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                            const yardstickVal = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                            if (!sailNumber || !boatClass || !skipper || yardstickVal <= 0) { console.warn(`JSON Import: Imported boat missing data, skipping: ID ${id}`); return null; }
                            return { id, sailNumber, boatClass, skipper, yardstick: yardstickVal };
                        }).filter(b => b !== null);
                    } else { boatList = []; }


                    if (parsedData.seriesData && Array.isArray(parsedData.seriesData)) {
                        series = parsedData.seriesData.map((s, index) => {
                            if (!s || typeof s !== 'object') { console.warn(`JSON Import: Invalid series data at index ${index}, skipping.`); return null; }
                            s.id = s.id || (Date.now() + index);
                            s.name = s.name || `Series ${s.id}`;
                            s.races = (Array.isArray(s.races) ? s.races : []).map((r, r_idx) => {
                                if (!r || typeof r !== 'object') return { raceNumber: r_idx + 1, date: null, entries: [], results: [] };
                                r.raceNumber = typeof r.raceNumber === 'number' ? r.raceNumber : r_idx + 1;
                                
                                const mapEntriesForImport = (entriesArray) => (Array.isArray(entriesArray) ? entriesArray : []).map(entry => {
                                    const boatFromList = entry.savedBoatId ? boatList.find(b => b.id === entry.savedBoatId) : null;
                                    let standardizedElapsedTime = entry.elapsedTime || '';
                                    if (entry.status === 'finished' && standardizedElapsedTime) {
                                        const seconds = timeToSeconds(standardizedElapsedTime);
                                        if (seconds >= 0) standardizedElapsedTime = secondsToTime(seconds);
                                    }
                                    return {...entry, elapsedTime: standardizedElapsedTime, savedBoatId: entry.savedBoatId || null, yardstick: entry.yardstick || boatFromList?.yardstick || 100 };
                                });

                                r.entries = mapEntriesForImport(r.entries);
                                r.results = mapEntriesForImport(r.results);
                                r.date = r.date || null;
                                return r;
                            });
                            s.isShortCourse = typeof s.isShortCourse === 'boolean' ? s.isShortCourse : false;
                            s.shortCourseSingleDiscardAfter5Races = typeof s.shortCourseSingleDiscardAfter5Races === 'boolean' ? s.shortCourseSingleDiscardAfter5Races : false;
                            s.numberOfRaces = typeof s.numberOfRaces === 'number' ? s.numberOfRaces : (s.isShortCourse ? s.races.length : 0);
                            s.discardThreshold = typeof s.discardThreshold === 'number' ? s.discardThreshold : 0;
                            s.dncScoringRule = ['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule) ? s.dncScoringRule : 'raceEntries';
                             if (!s.isShortCourse) {
                                const expectedNumRaces = s.numberOfRaces || 0;
                                if (s.races.length !== expectedNumRaces) {
                                   console.warn(`JSON Import: Fixing race structure for standard series "${s.name}". Expected ${expectedNumRaces}, found ${s.races.length}.`);
                                   let existingRacesData = new Map();
                                   s.races.forEach(r_item => { if (r_item && typeof r_item.raceNumber ==='number') existingRacesData.set(r_item.raceNumber, r_item); });
                                   let reconciledRaces = [];
                                   for (let i_race = 1; i_race <= expectedNumRaces; i_race++) {
                                       const existing = existingRacesData.get(i_race);
                                       const defaultYardstick = existing?.savedBoatId ? (boatList.find(b=>b.id === existing.savedBoatId)?.yardstick || 100) : 100;
                                       
                                       const mapEntriesForReconciliation = (entriesArray) => (Array.isArray(entriesArray) ? entriesArray : []).map(entry => {
                                           let stdTime = entry.elapsedTime || '';
                                           if (entry.status === 'finished' && stdTime) { const secs = timeToSeconds(stdTime); if (secs >=0) stdTime = secondsToTime(secs); }
                                           return {...entry, elapsedTime: stdTime, savedBoatId: entry.savedBoatId || null, yardstick: entry.yardstick || defaultYardstick};
                                       });

                                       reconciledRaces.push({
                                           raceNumber: i_race,
                                           date: existing?.date || null,
                                           entries: mapEntriesForReconciliation(existing?.entries),
                                           results: mapEntriesForReconciliation(existing?.results)
                                       });
                                   }
                                   s.races = reconciledRaces;
                                }
                            }
                            s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));
                            return s;
                        }).filter(s => s !== null);
                    } else { series = []; }


                    await saveDataToGoogleSheet();

                    refreshSeriesList(); refreshSeriesDropdowns(); renderBoatListTable(); populateSavedBoatDropdown();
                    entries = []; results = []; currentSeries = null; currentRace = null; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults();
                    if(seriesResultsTab?.classList.contains('active-tab')) calculateSeriesResults();
                    if(raceViewTab?.classList.contains('active-tab')) displayRaceViewer();
                    setActiveTab(seriesTab);
                    alert("Data imported from JSON and saved to Google Sheets successfully!");
                } catch (error) { console.error("Error during data import from JSON:", error); alert("Error importing data: " + error.message + ". Data not changed."); }
                finally { importFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importFileInput.value = null; };
            reader.readAsText(file);
        }

        async function importBoatList(event) {
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING BOAT LIST WILL REPLACE YOUR CURRENT SAVED BOAT LIST (in app & then Google Sheets). Series data will NOT be affected. Are you sure?")) { importBoatListFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result; let parsedData = JSON.parse(fileContent);
                    let importedList;
                    if (Array.isArray(parsedData)) {
                        importedList = parsedData;
                    } else if (parsedData && typeof parsedData === 'object' && Array.isArray(parsedData.boatListData)) {
                        importedList = parsedData.boatListData;
                    } else {
                        throw new Error("Invalid file format. Expected an array of boats or an object with a 'boatListData' array.");
                    }
                     const existingIds = new Set();
                     boatList = importedList.map((b, index) => {
                         if (!b || typeof b !== 'object') return null;
                         let id = b.id || (Date.now() + index + Math.random());
                         if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_json_bl";
                         existingIds.add(id);
                         const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                         const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                         const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                         const yardstickVal = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                         if (!sailNumber || !boatClass || !skipper || yardstickVal <= 0) { console.warn(`JSON Import (Boat List): Imported boat missing data, skipping: ID ${id}`); return null; }
                         return { id, sailNumber, boatClass, skipper, yardstick: yardstickVal };
                     }).filter(b => b !== null);

                    await saveDataToGoogleSheet();

                    renderBoatListTable(); populateSavedBoatDropdown();
                    alert("Boat list imported from JSON and saved to Google Sheets successfully!");
                } catch (error) { console.error("Error during boat list import from JSON:", error); alert("Error importing boat list: " + error.message + ". List not changed."); }
                finally { importBoatListFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importBoatListFileInput.value = null; };
            reader.readAsText(file);
        }

        async function initApp() {
            console.log("Initializing Sailing App (Google Sheets Mode)...");
            initYardsticks();

            if (calculateResultsBtn) { // Change button text on load
                calculateResultsBtn.textContent = "Calculate Results and Save";
            }

            await loadDataFromGoogleSheet();

            refreshSeriesList();
            refreshSeriesDropdowns();
            renderBoatListTable();
            setActiveTab(seriesTab); 

            if (exportAllDataBtn) exportAllDataBtn.addEventListener('click', exportAllData);
            if (importDataBtn && importFileInput) { importDataBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', importData); }
            if (exportBoatListBtn) exportBoatListBtn.addEventListener('click', exportBoatList);
            if (importBoatListBtn && importBoatListFileInput) { importBoatListBtn.addEventListener('click', () => importBoatListFileInput.click()); importBoatListFileInput.addEventListener('change', importBoatList); }

            console.log("App Initialized. Series loaded:", series.length, "Boats loaded:", boatList.length);
        }

         window.editEntry = editEntry; 
         window.removeEntry = removeEntry;
         window.updateStandardEntryInTable = updateStandardEntryInTable; 
         window.editSeries = editSeries;
         window.deleteSeries = deleteSeries;
         window.editBoatInList = editBoatInList;
         window.deleteBoatFromList = deleteBoatFromList;
         window.editShortCourseEntry = editShortCourseEntry;
         window.removeShortCourseEntry = removeShortCourseEntry;
         window.updateShortCourseEntry = updateShortCourseEntry;

        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
